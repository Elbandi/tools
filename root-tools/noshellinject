#!/bin/bash

# This script, noshellinject, creates a mount namespace,
# in which common shell commands (/bin/sh, /bin/bash, ...) are bind-mounted over with "notashell".
#
# Using notashell(1) is supposed to prevent shell-injections.
#
# notashell(1) bypasses shell only when the program, which is called by noshellinject, does
# directly execute an over-mounted shell (notashell switches NOTASHELL_INTERCEPT environment off).
# So in your untrusted-argument-validator script and any of its subprocesses,
# sh(1)/bash(1) may be called at your convenience.
# This is safe, because it's your control what you pass to them from the validator.
#
# One notable thing in its mechanics is that this re-enablement of real shells
# is done not by switching back to the original mount namespace,
# because the neglegent program (which calls system(3) inconsiderately) may
# switch privilege level so its child process can not switch namespaces,
# but by keep calling notashell(1) in guise of sh(1)/bash(1)
# but no longer having NOTASHELL_INTERCEPT makes notashell(1) call the real boys
# from /var/lib/notashell where they were previously saved (bind-mounted).
# Therefore, don't allow users to change NOTASHELL_INTERCEPT environment either.

set -e

if [ "$1" = --inner ]
then
	mkdir -p /var/lib/notashell
	
	# may extend if the neglegent program calls something else as shell
	shellnames=(sh dash bash)
	
	for shell in "${shellnames[@]}"
	do
		# can bind-mount existing paths only
		[ -f /var/lib/notashell/real-$shell ] || true > /var/lib/notashell/real-$shell
		# save the real shell for later use
		mount -o bind /bin/$shell /var/lib/notashell/real-$shell
	done
	
	for shell in "${shellnames[@]}"
	do
		mount -o bind /usr/tool/notashell /bin/$shell
	done
	
	shift
	export NOTASHELL_INTERCEPT=1
	exec "$@"
else
	exec unshare --mount -- "$0" --inner "$@"
fi
