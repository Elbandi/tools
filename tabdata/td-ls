#!/usr/bin/env perl

=pod

=head1 NAME

td-ls - ls(1)-like file list but more machine-parseable

=head1 SYNOPSIS

td-ls [I<OPTIONS>] [I<PATHS>]

=head1 OPTIONS, ls(1)-compatible

=over 4

=item -a (implied)

=item -g

=item -G, --no-group

=item -i, --inode

=item -l (implied)

=item -N, --literal (implied)

=item -n, --numeric-uid-gid

=item -o

=item --time=[atime, access, use, ctime, status, birth, creation, mtime, modification]

=item -R, --recursive

=back

=head1 OPTIONS, not ls(1)-compatible

=over 4

=item --devnum

=item -H, --no-header

=item --no-symlink-target

=item --add-field I<FIELD-NAME>

Append extra fields after the time field.
May be added multiple times.
See field names by B<--help-field-names> option.

=item --add-field-macro I<FORMAT>

Append extra fields after other extra fields added by B<--add-field> option, if any,
otherwise after the time field.
For valid I<FORMAT>s, see B<-printf> section in find(1).

=item --help-field-names

Show valid field names to be used for B<--add-field> option.

=back

=head1 DESCRIPTION

Columns are similar to good old ls(1):
PERMS (symbolic representation),
LINKS,
USERNAME (USERID if B<-n> option is given),
GROUPNAME (GROUPID if B<-n> option is given),
SIZE (in bytes),
time field is either ATIME, CTIME, or default MTIME (in full-iso format),
BASENAME,
and SYMLINKTARGET.

Column names are a bit different than td-trans-ls(1) produces, but this is intentional,
because fields by these 2 tools have slightly different meaning.
td-trans-ls(1) is less smart because it just transforms ls(1)'s output and
does not always know what is in the input exactly; while td-ls(1) itself controls
what data goes to the output.

No color support.

=head1 ENVIRONMENT

=over 4

=item QUOTING_STYLE

=item TIME_STYLE

B<TIME_STYLE> is ignored as well as I<--time-style> option.
Always show date-time in C<%F %T %z> strftime(3) format!
It's simply the most superior.
Equivalent to B<TIME_STYLE=full-iso>.

=back

=head1 SEE ALSO

td-select(1), td-filter(1), td-trans-ls(1)

=cut


use Getopt::Long qw/:config no_ignore_case bundling no_getopt_compat/;
use Pod::Usage;
use Data::Dumper;

%field_macro = (qw/devnum %D inode %i perms %M links %n username %u userid %U groupname %g groupid %G size %s 
	basename %f relpath %p dirpath %h symlinktarget %l
	depth %d fstype %F perms-octal %m ftype %y ltype %Y/,
	'atime', '%AF %AT %Az',
	'btime', '%BF %BT %Bz',
	'ctime', '%CF %CT %Cz',
	'mtime', '%TF %TT %Tz');

%time_types = qw/atime a access a use a ctime c status c birth b creation b mtime m modification m/;

@depthopts = qw/-mindepth 1 -maxdepth 1/;
$show_inode = 0;
$show_devnum = 0;
$uidgid_numeric = 0;
$hide_user = 0;
$hide_group = 0;
$recursive = 0;
$show_symlink_target = 1;
$show_header = 1;
$time_type = 'm';
@extra_fields = ();
@extra_macros = ();

GetOptions(
	'l' => sub{},
	'i|inode' => \$show_inode,
	'devnum' => \$show_devnum,
	'n|numeric-uid-gid' => \$uidgid_numeric,
	'G|no-group' => \$hide_group,
	'g' => \$hide_user,
	'o' => \$hide_group,
	'symlink-target!' => \$show_symlink_target,
	'R|recursive' => \$recursive,
	'header!' => \$show_header,
	'c' => sub{ $time_type = 'c'; },
	'u' => sub{ $time_type = 'a'; },
	'time=s' => sub{ $time_type = $time_types{$_[1]} or die "$0: unknown time type: $_[0]\n"; },
	'add-field=s@' => \@extra_fields,
	'add-field-macro=s@' => \@extra_macros,
	'help|?' => sub{ pod2usage(-exitval=>0, -verbose=>99); },
	'help-field-names' => sub{ print "$_\n" for sort keys %field_macro; exit 0; },
) or pod2usage(-exitval=>2, -verbose=>99);


@depthopts = () if $recursive;
@fields = ();
@wide_fields = ();

push @fields, 'devnum' if $show_devnum;
push @fields, 'inode' if $show_inode;
push @fields, 'perms', 'links';
push @fields, ($uidgid_numeric ? 'uid' : 'username') if not $hide_user;
push @fields, ($uidgid_numeric ? 'gid' : 'groupname') if not $hide_group;
push @fields, 'size';
push @fields, $time_type.'time';
push @fields, @extra_fields;

push @wide_fields, ($recursive ? 'relpath' : 'basename');
push @wide_fields, 'symlinktarget' if $show_symlink_target;

@field_macros = ();
push @field_macros, map {$field_macro{$_}} @fields;
push @field_macros, @extra_macros;
push @field_macros, map {$field_macro{$_}} @wide_fields;

if($show_header)
{
	@header = ();
	push @header, map {uc} @fields;
	push @header, map {uc} @extra_macros;
	push @header, map {uc} @wide_fields;
	print join("\t", @header)."\n";
}

exec 'find', @ARGV, @depthopts, '-printf', join("\t", @field_macros)."\n";


__END__

TODO QUOTING_STYLE
