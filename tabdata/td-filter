#!/usr/bin/env perl

=pod

=head1 NAME

td-filter - Show only those records from the input tabular data stream which match to the conditions.

=head1 USAGE

td-filter [I<OPTIONS>] [--] I<COLUMN> I<OPERATOR> I<R-VALUE> [[or] I<COLUMN> I<OPERATOR> I<R-VALUE> [[or] ...]]

td-filter [I<OPTIONS>] --perl I<EXPR>

=head1 DESCRIPTION

Pass through those records which match at least one of the conditions (inclusive OR).
A condition consists of a triplet of I<COLUMN>, I<OPERATOR>, and I<R-VALUE>.
You may put together conditions conjunctively (AND) by chaining multiple td-filter(1) commands by shell pipes.
Example:

  td-filter NAME eq john NAME eq jacob | tr-filter AGE -gt 18

This gives the records with either john or jacob, and all of them will be above 18.

The optional word "B<or>" between triplets makes your code more explicite.

td-filter(1) evaluates the Perl expression in the second form and passes through records
only if the result is true-ish in Perl (non zero, non empty string, etc).
Each field's value is in @F by index, and in %F by column name.
You can implement more complex conditions in this way.

=head1 OPTIONS

=over 4

=item -H, --no-header

do not show headers

=item -h, --header

show headers (default)

=item -i, --ignore-non-existing-columns

do not treat non-existing (missing or typo) column names as failure

=item -w, --warn-non-existing-columns

only show warning on non-existing (missing or typo) column names, but don't fail

=item -N, --no-fail-non-numeric

do not fail when a non-numeric r-value is given to a numeric operator

=item -W, --no-warn-non-numeric

do not show warning when a non-numeric r-value is given to a numeric operator

=back

=head1 OPERATORS

These operators are supported, semantics are the same as in Perl, see perlop(1).

 == != <= >= < > =~ !~ eq ne gt lt

For your convenience, not to bother with escaping, you may also use these operators as alternatives to the canonical ones above:

=over 4

=item is

string equality (B<eq>)

=item is not

=item isnt

=item isnot

string inequality (B<ne>)

=item -eq

numerical equality (B<==>)

=item -ne

numerical inequality (B<!=>)

=item <>

numerical inequality (B<!=>)

=item -gt

numerical greater than (B<E<gt>>)

=item -ge

numerical greater or equal (B<E<gt>=>)

=item -lt

numerical less than (B<E<lt>>)

=item -le

numerical less or equal (B<E<lt>=>)

=item match

regexp match (B<=~>)

=item notmatch

=item does not match

negated regexp match (B<!~>)

=back

Other operators:

=over 4

=item [is] one of

I<R-VALUE> is split into pieces by commas (C<,>) and
equality to at least one of them is required

=item [contains | has] [whole word]

Substring match.
Plural forms ("contain" and "have") are also accepted.
Optional I<whole word> is a literal part of the operator.

=item [contains | has] one of [whole word]

Similar to B<is one of>, but substring match is checked
instead of full string equality.
Optional I<whole word> is a literal part of the operator.

=back

Operators may be preceeded by I<not>, I<does not>, I<do not> to negate their effect.

=head1 CAVEATS

If there is no I<COLUMN> column in the input data, it's silently considered empty.
td-filter(1) does not need I<R-VALUE> to be quoted or escaped, however your shell may do.

=cut

use Switch;
use List::MoreUtils qw/all any none/;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';
do '/usr/lib/tool/perl5/tabdata/common.pl' or die "$@";

@Filter = ();
$Expr = undef;

%operator_alias = (
	'-eq', '==',
	'is',  'eq',
	'<>',  '!=',
	'-ne', '!=',
	'isnt',   'ne',
	'isnot',  'ne',
	'is not', 'ne',
	'-gt', '>',
	'-lt', '<',
	'-ge', '>=',
	'-le', '<=',
	'notmatch', '!~',
	'match', '=~',
);
%operator_alterform = (
	'have',    'contains',
	'has',     'contains',
	'contain', 'contains',
);

if($ARGV[0] eq '--perl')
{
	shift @ARGV;
	die "$0: missing Perl expression\n" unless @ARGV;
	$Expr = join ';', @ARGV;
}
else
{
	while(scalar @ARGV)
	{
		shift @ARGV if $ARGV[0] eq 'or';
		
		my $column = shift @ARGV;
		
		my $negation = 0;
		if($ARGV[0] eq 'not') { $negation = 1; shift @ARGV; }
		elsif($ARGV[0] ~~ ['does', 'do'] and $ARGV[1] eq 'not') { $negation = 1; shift @ARGV; shift @ARGV; }
		
		my $operator = shift @ARGV or die "$0: missing operator for: $column\n";
		if($operator eq 'is' and $ARGV[0] eq 'not') { $operator .= ' ' . shift @ARGV; }
		$operator = $operator_alterform{$operator} if exists $operator_alterform{$operator};
		if($operator ~~ ['contains', 'is'] and $ARGV[0] ~~ ['one', 'any'] and $ARGV[1] eq 'of')
			{ $operator .= '-one-of'; shift @ARGV; shift @ARGV; }
		
		$operator = $operator_alias{$operator} if exists $operator_alias{$operator};
		
		my $wholeword = 0;
		if($operator ~~ [qw/contains contains-one-of/] and $ARGV[0] eq 'whole' and $ARGV[1] eq 'word')
			{ $wholeword = 1; shift @ARGV; shift @ARGV; }
		
		my $rvalue = shift @ARGV;
		die "$0: missing r-value for: $column $operator\n" if not defined $rvalue;
		
		
		unless($operator ~~ [qw/== != <= >= < > =~ !~ eq ne gt lt is-one-of contains contains-one-of/])
		{
			die "$0: unknown operator: $operator\n";
		}
		
		if($operator ~~ [qw/== != <= >= < >/] and $rvalue !~ /^[+-]?[0-9]\d*(.\d+|)(E[+-]?\d+|)$/i)
		{
			warn "$0: operator ($operator) is numeric but r-value ($rvalue) is not\n" if $OptWarnNonNumericRValue;
			exit -1 if $OptFailNonNumericRValue;
		}
		
		push @Filter, {'field'=>$column, 'operator'=>$operator, 'negation'=>$negation, 'value'=>$rvalue, 'wholeword'=>$wholeword};
	}
}

process_header(scalar <STDIN>);

if(not defined $Expr)
{
	for my $filter (@Filter)
	{
		my $colname = $filter->{'field'};
		if(not exists $Header{$colname})
		{
			my $cols = join ", ", @Header;
			warn "$0: $colname: no such column. known columns: $cols\n" if $OptWarnBadColumnNames;
			exit 3 if $OptFailBadColumnNames;
		}
	}
}

if($OptShowHeader and length $HeaderLine)
{
	print $HeaderLine.$RS;
}

while(my @Field = read_record(\*STDIN))
{
	if(defined $Expr)
	{
		my @F = @Field;
		my %F = map {$_=>$Field[$Header{$_}]} keys %Header;
		$pass = eval $Expr;
		warn $@ if $@;
	}
	else
	{
		$pass = 0;
		
		for my $filter (@Filter)
		{
			my $left_data = exists $Header{$filter->{'field'}} ? $Field[$Header{$filter->{'field'}}] : '';
			my $right_data = $filter->{'value'};
			my $operator = $filter->{'operator'};
			my $result;
			
			if($filter->{'wholeword'})
			{
				# have to match "whole word" - simple substring match won't be enough.
				# transform "contains" and "contains-one-of" operators into a regexp match.
				
				if($operator eq 'contains-one-of')
				{
					$right_data = '\b(' . (join '|', map { quotemeta($_) } split /,/, $right_data) . ')\b';
				}
				elsif($operator eq 'contains')
				{
					$right_data = '\b' . quotemeta($right_data) . '\b';
				}
				else { die "$0: should not happen\n"; }
				$operator = '=~';
			}
			
			switch($operator)
			{
				case 'contains'
				{
					$result = 1 + index $left_data, $right_data;
				}
				case 'is-one-of'
				{
					$result = any { $left_data eq $_ } split /,/, $right_data;
				}
				case 'contains-one-of'
				{
					$result = any { 1 + index $left_data, $_ } split /,/, $right_data;
				}
				else
				{
					my $left_code = '$left_data';
					my $right_code = '$right_data';
					$right_code = "/$right_code/" if $operator ~~ ['=~', '!~'];
					$result = eval "$left_code $operator $right_code";
				}
			}
			
			$result = !$result if $filter->{'negation'};
			
			if($result)
			{
				$pass = 1;
				last;
			}
		}
	}
	
	if($pass)
	{
		print join($FS, @Field).$RS;
	}
}
