#!/usr/bin/env perl

=pod

=head1 NAME

td-filter - Show only those records from the input tabular data stream which match to the conditions.

=head1 USAGE

td-filter [<OPTIONS>] [--] <COLUMN> <OPERATOR> <R-VALUE> [<COLUMN> <OPERATOR> <R-VALUE> [...]]

td-filter [<OPTIONS>] --perl <EXPR>

=head1 DESCRIPTION

Pass through those records which match at least one of the conditions (inclusive OR).
You may put together conditions conjunctively (AND) by chaining multiple td-filter commands in the pipe.
Example:

  td-filter NAME eq john NAME eq jacob | tr-filter AGE -gt 18

This gives the records with either john or jacob, and all of them will be above 18.

td-filter(1) evaluates the Perl expression in the second form and passes through only
if the result is true-ish in Perl (non zero, non empty string, etc).
Each field's value is in @F by index, and in %F by column name.
You can implement more complex conditions in this way.

=head1 OPTIONS

=over 4

=item -H, --no--header

do not show headers

=item -h, --header

show headers (default)

=item -i, --ignore-nonexisting-columns

do not treat non-existing (missing or typo) column names as failure

=item -w, --warn-nonexisting-columns

only show warning on non-existing (missing or typo) column names, but don't fail

=back

=head1 OPERATORS

These operators are supported, semantics are the same as in Perl, see perlop(1).

 == != <= >= < > =~ !~ eq ne gt lt

For your convenience, not to bother with escaping, you may also use these operators as alternatives to the canonical ones above:

is : string equality

is not, isnt, isnot : string inequality

-eq : numerical equality

-ne : numerical inequality

<>  : numerical inequality

-gt : numerical greater than

-ge : numerical greater or equal

-lt : numerical less than

-le : numerical less or equal

match : regexp match

notmatch : negated regexp match

have, has : substring match

=head1 CAVEATS

If there is no <COLUMN> column in the input data, it's silently considered empty.
<R-VALUE> does not need quoting or escaping.

=cut

use feature qw/switch/;
do '/usr/lib/tool/perl5/tabdata/common.pl' or die "$@";

@Filter = ();
$Expr = undef;

%operator_alias = (
	'-eq', '==',
	'is',  'eq',
	'<>',  '!=',
	'-ne', '!=',
	'isnt',   'ne',
	'isnot',  'ne',
	'is not', 'ne',
	'-gt', '>',
	'-lt', '<',
	'-ge', '>=',
	'-le', '<=',
	'notmatch', '!~',
	'match', '=~',
	'have', 'has',
);

if($ARGV[0] eq '--perl')
{
	shift @ARGV;
	die "$0: missing Perl expression\n" unless @ARGV;
	$Expr = join ';', @ARGV;
}
else
{
	while(scalar @ARGV)
	{
		my $column = shift @ARGV;
		
		my $negation = 0;
		if($ARGV[0] eq 'not') { $negation = 1; shift @ARGV; }
		
		my $operator = shift @ARGV or die "$0: missing operator for: $column\n";
		$operator .= ' ' . shift @ARGV if $operator eq 'is' and $ARGV[0] eq 'not';
		
		my $rvalue = shift @ARGV or die "$0: missing r-value for: $column $operator\n";
		
		
		# operator aliases
		$operator = $operator_alias{$operator} if exists $operator_alias{$operator};
		
		unless($operator ~~ [qw/== != <= >= < > =~ !~ eq ne gt lt has/])
		{
			die "$0: unknown operator: $operator\n";
		}
		
		push @Filter, {'field'=>$column, 'operator'=>$operator, 'negation'=>$negation, 'value'=>$rvalue,};
	}
}

process_header(scalar <STDIN>);

if(not defined $Expr)
{
	for my $filter (@Filter)
	{
		my $colname = $filter->{'field'};
		if(not exists $Header{$colname})
		{
			my $cols = join ", ", @Header;
			warn "$0: $colname: no such column. known columns: $cols\n" if $OptWarnBadColumnNames;
			exit 3 if $OptFailBadColumnNames;
		}
	}
}

if($OptShowHeader)
{
	print $HeaderLine.$RS;
}

while(my @Field = read_record(\*STDIN))
{
	if(defined $Expr)
	{
		my @F = @Field;
		my %F = map {$_=>$Field[$Header{$_}]} keys %Header;
		$pass = eval $Expr;
		warn $@ if $@;
	}
	else
	{
		$pass = 0;
		
		for my $filter (@Filter)
		{
			my $left_data = exists $Header{$filter->{'field'}} ? $Field[$Header{$filter->{'field'}}] : '';
			my $right_data = $filter->{'value'};
			my $operator = $filter->{'operator'};
			my $result;
			
			given($operator)
			{
				when('has')
				{
					$result = 1 + index $left_data, $right_data;
				}
				default
				{
					my $left_code = '$left_data';
					my $right_code = '$right_data';
					$right_code = "/$right_code/" if $operator ~~ ['=~', '!~'];
					$result = eval "$left_code $operator $right_code";
				}
			}
			
			$result = !$result if $filter->{'negation'};
			
			if($result)
			{
				$pass = 1;
				last;
			}
		}
	}
	
	if($pass)
	{
		print join($FS, @Field).$RS;
	}
}
