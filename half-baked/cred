#!/bin/bash

# need to set these shell options before they are relied upon when bash parses the big { ... } block later down.
shopt -s nocasematch
shopt -s expand_aliases
# aliases in non-interactive bash script are not evaluated in the same scope where they are defined,
# but they are in the big { ... } block below.
alias set_site='if [ -z "${site:-}" ]; then set_site_func "${1:-}"; shift; fi;'

{
set -eE
set -o pipefail
set -u

. /usr/lib/tool/bash-utils
. /usr/lib/tool/ansi-codes

TAB=$'\t'

print_traceback()
{
	local i stack_size=${#FUNCNAME[@]}
	for (( i=1; i<stack_size; i++ )); do
		local func="${FUNCNAME[$i]}"
		[[ $func = "" ]] && func=MAIN
		local linen="${BASH_LINENO[$(( i - 1 ))]}"
		local src="${BASH_SOURCE[$i]}"
		[[ "$src" = "" ]] && src=non_file_source
		
		echo -n "$ANSI_bold$ANSI_fg_black"
		echo "  function: $func"
		echo "  file: $src (line $linen)"
		echo -n "$ANSI_reset"
		
		local line_number_text_sep='| '
		nl -ba -w ${#linen} -s " $line_number_text_sep" "$src" | grep -C 2 -E "^\s*$linen " |\
			prefixlines "    " |\
			sed -e "s/^\(\s*$linen\) \(.\{${#line_number_text_sep}\}\)\(.*\)/\1-\2$ANSI_italic\3$ANSI_normal/" |\
			sd '^' "$ANSI_bold$ANSI_fg_black" | sd '$' "$ANSI_reset"
	done
}

trap 'print_traceback >&2' ERR

set_site_func()
{
	local param=$1
	if [ -z "$1" ]
	then
		errx 1 "Enter site name or directory!"
	elif [ -d "$param" ]
	then
		site=`basename "$param"`
	else
		site=$1
	fi
}

is_secret()
{
	[[ $1 =~ password|key|cvc|secret|pin ]]
}

do_clip()
{
	local prop=$1
	if type copyq 1>/dev/null 2>&1 && is_secret "$prop"
	then
		copyq_monitoring=`copyq monitoring`
		if [ "$copyq_monitoring" = true ]
		then
			copyq disable
		fi
		copyq copy -
		if [ "$copyq_monitoring" = true ]
		then
			copyq enable
		fi
	else
		xclip -i -selection clipboard
	fi
}


basedir=~/cred
site=''


if [ "${1:-}" = site ]
then
	shift || true
	set_site
fi

subcmd=${1:-}
shift || true



case "$subcmd" in
(dump)
	set_site
	options=("$@")
	
	(
		cd "$basedir/$site"
		GLOBIGNORE=${GLOBIGNORE:-}${GLOBIGNORE:+:}".:..:.[!/.]*:..[!/]*:-*"
		for file in *
		do
			if [ ! -f "$file" ]
			then
				continue
			fi
			if is_secret "$file"
			then
				if in_list reveal-secrets "${options[@]}"
				then
					true
				elif in_list hash-secrets "${options[@]}"
				then
					hash=`cat "$file" | md5sum | cut -c 1-32`
					echo "$file$TAB$hash$TAB""hash-algo=md5"
					continue
				else
					echo "$file"$'\t'"*****"
					continue
				fi
			fi
			
			grep . "$file" | prefixlines "$file"$'\t'
		done
		
		site=${site%/}
		if [[ $site =~ / ]]
		then
			parent=${site%/*}
			cred dump "$parent" "${options[@]}"
		fi
	)
	;;
(password)
	set_site
	cat "$basedir/$site/PASSWORD"
	;;
(list-sites)
	find -L "$basedir" -path "$basedir/${1:-}*" -type d -printf "%P\n"
	;;
(prop|clip)
	set_site
	prop=${1:?'enter property name!'}
	shift
	if [ $# = 0 ]
	then
		case "$subcmd" in
		(prop)
			if is_secret "$prop"
			then
				warnx "$prop is a secret."
				warnx "enter 'cred [...] prop [...] $prop show' explicitely, or"
				warnx "more preferably 'cred [...] prop [...] $prop clip' to copy to the clipboard!"
				false
			else
				cat "$basedir/$site/$prop"
			fi
			;;
		(clip)
			cat "$basedir/$site/$prop" | do_clip "$prop"
			;;
		esac
	elif [ "$subcmd" = prop ]
	then
		case "$1" in
		(set)
			shift
			val=$*
			mkdir -p "$basedir/$site"
			printf '%s' "$val" > "$basedir/$site/$prop"
			;;
		(edit)
			mkdir -p "$basedir/$site"
			"${EDITOR:-$VISUAL}" "$basedir/$site/$prop"
			;;
		(read)
			if is_secret "$prop"
			then
				read -s -p "$prop: " -e val
			else
				read -p "$prop: " -e val
			fi
			printf '%s' "$val" > "$basedir/$site/$prop"
			;;
		(del)
			rm "$basedir/$site/$prop"
			;;
		(show)
			cat "$basedir/$site/$prop"
			;;
		(clip)
			cat "$basedir/$site/$prop" | do_clip "$prop"
			;;
		(*)
			false "invalid argument"
			;;
		esac
	fi
	;;
(fill-form)
	set_site
	if [ $# -gt 0 ]
	then
		strings=''
		for prop in "$@"
		do
			val=`cat "$basedir/$site/$prop"`
			strings="$strings$val"$'\t'
		done
		xdotool key Alt+Tab type "$strings"
	else
		errx 1 "Enter property names in order to fill the form on the window brought to focus by Alt+Tab."
	fi
	;;
(list-props)
	set_site
	find "$basedir/$site" -type f -printf "%P\n"
	;;
(generate-password)
	set_site
	newpwd=$(pwgen -y 8 1)$(pwgen -y 8 1)
	[ -n "$newpwd" ]
	pwdfile=$basedir/$site/PASSWORD
	mkdir -p "$basedir/$site"
	if [ -s "$pwdfile" ]
	then
		cur_pwd=`cat "$pwdfile"`
		atime=`stat -c %x "$pwdfile"`
		now=`date +'%F %T.%N %z'`
		echo "$atime	$now	$cur_pwd" >> "$basedir/$site/OLDPASSWORDS"
	fi
	printf '%s' "$newpwd" > "$pwdfile"
	;;
(compscript)
	cat <<'EOF'
_autocomplete_cred() {
	local compreply
	local curr_word=${COMP_WORDS[$COMP_CWORD]}
	local prev_word=${COMP_WORDS[$[COMP_CWORD - 1]]}
	local site_subcmds="list-sites dump generate-password list-props prop clip fill-form"
	
	case $COMP_CWORD in
	(1)
		compreply="compscript site $site_subcmds"
		;;
	(2)
		local site=$curr_word; site=${site/#'~/'/$HOME/}
		compreply=`cred list-sites "$site"`
		;;
	(*)
		local subcmd=${COMP_WORDS[1]}
		local site=${COMP_WORDS[2]}; site=${site/#'~/'/$HOME/}
		local cword_idx=$COMP_CWORD
		if [ "$subcmd" = site ]
		then
			if [ $COMP_CWORD = 3 ]
			then
				compreply="$site_subcmds"
			else
				subcmd=${COMP_WORDS[3]}
				let cword_idx-=1
			fi
		fi
		case "$subcmd" in
		(prop)
			case $cword_idx in
			(3)
				compreply=`cred list-props "$site"`
				;;
			(4)
				compreply="set edit read del show clip"
				;;
			esac
			;;
		(clip|fill-form)
			compreply=`cred list-props "$site"`
			;;
		(dump)
			case $cword_idx in
			(3)
				compreply="reveal-secrets mask-secrets hash-secrets"
				;;
			esac
		esac
		;;
	esac
	COMPREPLY=($(compgen -W "$compreply" -- "${COMP_WORDS[$COMP_CWORD]}"))
	return 0
}
complete -F _autocomplete_cred cred
# use this in your bash session by eg: eval "$(cred compscript)"
EOF
	;;
(*)
	warnx 'Use tab-completion!'
	warnx 'Example: eval "$(cred compscript)"'
	false
	;;
esac

exit
}
