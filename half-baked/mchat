#!/usr/bin/perl

use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev require_order/;
use Pod::Usage;
use IO::Socket::INET;
use IO::Socket::Multicast;
use IO::Select;
use Sys::Hostname;
use List::MoreUtils qw/all any none first_index/;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';

$NUL = chr 0;
$SOH = chr 1;
$STX = chr 2;
$ETX = chr 3;
$EOT = chr 4;
$LF = "\n";

sub uuidgen
{
	open my $f, '<', '/proc/sys/kernel/random/uuid' or die "$0: open: $!\n";
	my $uuid = <$f>;
	chomp $uuid;
	close $f;
	return $uuid;
}

sub network_interfaces
{
	my @ifaces;
	for my $iface_path (glob "/sys/class/net/*")
	{
		my ($iface) = $iface_path =~ m{/([^/]+)$};
		push @ifaces, $iface;
	}
	return @ifaces;
}

sub local_ipv4_addresses
{
	return grep { /^[\d\.]+$/; } split /\s+/, `hostname -I`;
}

sub erase_prompt
{
	print STDERR "\r\x1B[K";
	$prompt_was_erased = 1;
}

sub protocolname
{
	my $num = shift;
	foreach my $const_name (keys %Socket::)
	{
		if($const_name =~ /^IPPROTO_(.+)/)
		{
			my $proto = $1;
			my $name = "Socket::$const_name";
			return $proto if $num == &$name();
		}
	}
	return "UNKNOWN($num)";
}


$anycast_addr = '0.0.0.0';
$broadcast_addr = '255.255.255.255';
$|++;

$OptPort = 1992;
$OptMulticastAddr = '239.199.2.0';  # i chose this address for this application
$OptBroadcastSend = 0;
$OptBroadcastRead = 0;
$OptNick = hostname;
@OptUnicast = ();

=pod

=head1 NAME

mchat - IP Multicast chat

=head1 OPTIONS

=over 4

=item -B, --broadcast-send

=item -b, --broadcast-read

Send and/or receive messages on broadcast.
Default is multicast-only.

=item --multicast-addr I<ADDR>

=item -p, --port I<NUM>

=item -n, --nick I<STRING>

=back

=head1 SEE ALSO

write(1), wall(1), rlwrap(1)

=cut

GetOptions(
	'B|broadcast-send!' => \$OptBroadcastSend,
	'b|broadcast-read!' => \$OptBroadcastRead,
	'multicast-addr=s' => \$OptMulticastAddr,
	'u|unicast=s@' => \@OptUnicast,
	'p|port=i' => \$OptPort,
	'n|nick=s' => \$OptNick,
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'<>' => sub { unshift @ARGV, @_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);



sub shout
{
	my $line = shift;
	my $meta = shift;
	
	$meta->{msgid} = uuidgen() unless exists $meta->{msgid};
	$meta->{nick} = $OptNick unless exists $meta->{nick};
	$sent_msgid{$meta->{msgid}} = 1;
	
	my $prepend = '';
	for my $metakey (keys %$meta)
	{
		$prepend .= $SOH . $metakey;
		$prepend .= '=' . $meta->{$metakey} if defined $meta->{$metakey};
	}
	$line = $prepend . $STX . $line;
	
	my $sent = 0;
	for my $writer (@net_writers)
	{
		if(ref $writer eq 'IO::Socket::Multicast')
		{
			for my $iface (network_interfaces())
			{
				if(eval { $writer->mcast_if($iface); 1 })
				{
					$writer->mcast_send($line, $mcast_dest);
					$sent++;
				}
				else
				{
					unless($!{EADDRNOTAVAIL} or $@ =~ /^interface is not multicast capable/)
					{
						warn "Could not set interface to $iface: $!: $@\n";
					}
				}
			}
		}
		else
		{
			if($writer->protocol == Socket::IPPROTO_TCP and not $writer->connected)
			{
			}
			else
			{
				$writer->send($line . ($writer->protocol == Socket::IPPROTO_TCP ? $EOT : ''), 0);
				$sent++;
			}
		}
	}
	
	if($sent == 0)
	{
		warn "there was no working socket to send to.\n";
	}
}


$select = IO::Select->new();
$select->add(\*STDIN);

@net_readers = ();
if($OptBroadcastRead)
{
	my $bcast_reader = IO::Socket::INET->new(
		LocalPort => $OptPort,
		Proto	 => 'udp',
		ReuseAddr => 1,
		ReusePort => 1,
	) or die "Could not create broadcast receiver socket: $!\n";
	warn "broadcast receiver created\n";
	push @net_readers, $bcast_reader;
	$select->add($bcast_reader);
}

my $multicast_reader = IO::Socket::Multicast->new(
	LocalPort => $OptPort,
	Proto	 => 'udp',
	ReuseAddr => 1,
	ReusePort => 1,
) or die "Could not create multicast receiver socket: $!\n";
for my $local_ip (local_ipv4_addresses())
{
	if($multicast_reader->mcast_add($OptMulticastAddr, $local_ip))
	{
		push @net_readers, $multicast_reader;
	}
	else
	{
		warn "Could not join to multicast group $OptMulticastAddr on local interface $local_ip: $!\n";
	}
}
warn "multicast receiver created\n";
$select->add($multicast_reader);


# TODO support icmp listener
# TODO support raw ip listener
my $anycast_listener_udp = IO::Socket::INET->new(
	LocalAddr => '0.0.0.0',
	LocalPort => $OptPort,
	Proto	  => 'udp',
	ReuseAddr => 1,
	ReusePort => 1,
) or die "Could not create anycast receiver UDP socket: %s\n", $!;
warn "anycast udp receiver created\n";
push @net_readers, $anycast_listener_udp;
$select->add($anycast_listener_udp);

my $anycast_listener_tcp = IO::Socket::INET->new(
	LocalAddr => '0.0.0.0',
	LocalPort => $OptPort,
	Proto	  => 'tcp',
	Listen    => SOMAXCONN,
	ReuseAddr => 1,
	ReusePort => 1,
) or die "Could not create anycast receiver TCP socket: %s\n", $!;
warn "anycast tcp receiver created\n";
push @net_readers, $anycast_listener_tcp;
$select->add($anycast_listener_tcp);



@net_writers = ();
if($OptBroadcastSend)
{
	for my $local_ip (local_ipv4_addresses())
	{
		my $net_write = IO::Socket::INET->new(
			LocalAddr => $local_ip,
			PeerPort  => $OptPort,
			PeerAddr  => $broadcast_addr,
			Broadcast => 1,
			ReuseAddr => 1,
			ReusePort => 1,
			Proto	 => 'udp',
		) or warn "Could not create broadcast sender socket on local interface $local_ip: $!\n";
		next unless $net_write;
		warn "broadcast sender bound to local IP $local_ip\n";
		push @net_writers, $net_write;
	}
}

$mcast_dest = sockaddr_in($OptPort, inet_aton($OptMulticastAddr));
$multicast_write = IO::Socket::Multicast->new(
	LocalPort => $OptPort,
	Proto	 => 'udp',
	ReuseAddr => 1,
	ReusePort => 1,
) or warn "Could not create multicast sender socket: $!\n";
$multicast_write->mcast_loopback(0);
$multicast_write->mcast_add($OptMulticastAddr) or die "Could not join to multicast group $OptMulticastAddr: $!\n";
warn "multicast sender created\n";
push @net_writers, $multicast_write;


for my $target (@OptUnicast)
{
	my ($addr, $port, $proto) = $target =~ /^([^:]+)(?::(\d+))?(?:\/(tcp|udp))?$/;
	# TODO support icmp, raw ip
	if(not length $addr)
	{
		die "unknown target address '$target'\n";
	}
	my $proto = $proto || 'udp';
	my $port = $port || $OptPort;
	my $sock = IO::Socket::INET->new(
		PeerAddr  => $addr,
		PeerPort  => $port,
		Proto	  => $proto,
		ReuseAddr => 1,
		ReusePort => 1,
		Blocking  => 0,
	) or die sprintf "Could not create unicast sender %s:%d/%s socket: %s\n", $addr, $port, $proto, $!;
	warn sprintf "unicast sender %s:%d/%s created\n", $addr, $port, $proto;
	push @net_writers, $sock;
	$select->add($sock);
}



warn "no any network interface to listen to!\n" unless @net_readers;
warn "no any network interface to bind to!\n" unless @net_writers;


%sent_msgid = ();
%received_msgid = ();
%nick_at_ip = ();
$prompt_was_erased = 1;

shout(undef, {scan=>undef,});

while (1)
{
	print STDERR ">>> " if $prompt_was_erased and $select->exists(\*STDIN);
	$prompt_was_erased = 0;
	
	my @ready = $select->can_read();
	for my $fh (@ready)
	{
		if ($fh eq \*STDIN)
		{
			my $line = <STDIN>;
			$prompt_was_erased = 1;
			unless(defined $line)
			{
				erase_prompt;
				$select->remove(\*STDIN);
				next;
			}
			next if $line eq $/;
			shout($line, {});
		}
		else
		{
			my $data;
			my $peer_ip;
			
			if($fh->protocol == Socket::IPPROTO_TCP)
			{
				if(any {$fh eq $_} @net_readers)
				{
					if(my $connection = $fh->accept)
					{
						$connection->autoflush(1);
						erase_prompt;
						warn sprintf "new connection from %s:%d on %s:%d/%s listener\n",
							$connection->peerhost, $connection->peerport,
							$connection->sockhost, $connection->sockport, protocolname($connection->protocol);
						$select->add($connection);
						push @net_writers, $connection;
					}
					else
					{
						erase_prompt;
						warn sprintf "can not accept connection on %s:%s/%s listener: %s\n", $fh->sockaddr, $fh->sockport, protocolname($fh->protocol), $!;
					}
					next;
				}
				else
				{
					# TODO restart unicast sender if...
					if(eof($fh))
					{
						$select->remove($fh);
						delete $net_writers[first_index {$_ eq $connection} @net_writers];
						erase_prompt;
						warn sprintf "connection from %s:%d on %s:%d/%s listener closed\n",
							$fh->peerhost, $fh->peerport,
							$fh->sockhost, $fh->sockport, protocolname($fh->protocol);
						$fh->close;
						next;
					}
					local $/ = $EOT;
					$data = <$fh>;
					chomp $data;
					$peer_ip = $fh->peerhost;
				}
			}
			else
			{
				my $remote = $fh->recv($data, 4096);
				my ($peerport, $peeraddr) = sockaddr_in($remote);
				$peer_ip = inet_ntoa($peeraddr);
			}
			
			my %metadata = ();
			while($data =~ s/^\x01([^=\x00-\x1F]+)(?:=([^\x01\x02]*))?//)
			{
				$metadata{$1} = $2;
			}
			
			my $msgid = $metadata{msgid} // uuidgen();
			next if exists $sent_msgid{$msgid};
			my $nick = $metadata{nick};
			
			if(not $peer_ip ~~ [keys %nick_at_ip])
			{
				erase_prompt;
				printf "%s is at %s\n", $nick || '(anon)', $peer_ip;
			}
			
			if(exists $nick_at_ip{$peer_ip} and $nick_at_ip{$peer_ip} ne $nick)
			{
				erase_prompt;
				printf "%s is transmitting from %s, from now on, instead of %s\n", $nick || '(anon)', $peer_ip, $nick_at_ip{$peer_ip} || '(anon)';
			}
			$nick_at_ip{$peer_ip} = $nick;
			
			next if exists $received_msgid{$msgid};
			$received_msgid{$msgid} = 1 if defined $metadata{msgid};  # remember this message only if the sender set the msgid, not us.
			
			$data =~ s/^\x02//;
			$data =~ s/$LF$//;
			if(length $data)
			{
				$data =~ s/[\x00-\x1F\x7F]/my $c = ord $&; sprintf "\x1B[7m^%c\x1B[27m", $c < 0x60 ? $c+0x40 : $c-0x40/eg;
				erase_prompt;
				printf "%s >>> %s\n", $nick || $peer_ip, $data;
			}
			
			if(exists $metadata{scan})
			{
				shout(undef, {present=>1,});
			}
		}
	}
}
