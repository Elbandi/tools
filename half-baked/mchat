#!/usr/bin/perl

use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev require_order/;
use Pod::Usage;
use IO::Socket::INET;
use IO::Socket::Multicast;
use IO::Select;
use Sys::Hostname;
use List::MoreUtils qw/all any none first_index/;
use Errno;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';

$NUL = chr 0;
$SOH = chr 1;
$STX = chr 2;
$ETX = chr 3;
$EOT = chr 4;
$LF = "\n";

$max_msg_len = 4096;


sub uuidgen
{
	open my $f, '<', '/proc/sys/kernel/random/uuid' or die "$0: open: $!\n";
	my $uuid = <$f>;
	chomp $uuid;
	close $f;
	return $uuid;
}

sub network_interfaces
{
	my @ifaces;
	for my $iface_path (glob "/sys/class/net/*")
	{
		my ($iface) = $iface_path =~ m{/([^/]+)$};
		push @ifaces, $iface;
	}
	return @ifaces;
}

sub local_ipv4_addresses
{
	return grep { /^[\d\.]+$/; } split /\s+/, `hostname -I`;
}

sub erase_prompt
{
	print STDERR "\r\x1B[K";
	$prompt_was_erased = 1;
}

sub protocolname
{
	my $num = shift;
	foreach my $const_name (keys %Socket::)
	{
		if($const_name =~ /^IPPROTO_(.+)/)
		{
			my $proto = $1;
			my $name = "Socket::$const_name";
			return $proto if $num == &$name();
		}
	}
	return "UNKNOWN($num)";
}


$anycast_addr = '0.0.0.0';
$broadcast_addr = '255.255.255.255';
$|++;

$OptPort = 1992;
$OptMulticastAddr = '239.199.2.0';  # i chose this address for this application
$OptBroadcastSend = 0;
$OptBroadcastRead = 0;
$OptNick = hostname;
@OptUnicast = ();

=pod

=head1 NAME

mchat - IP Multicast chat

=head1 OPTIONS

=over 4

=item -B, --broadcast-send

=item -b, --broadcast-read

Send and/or receive messages on broadcast.
Default is multicast-only.

=item --multicast-addr I<ADDR>

=item -u, --unicast I<ADDR>[:I<PORT>][/[B<tcp> | B<udp>]]

Initiate connection to this target.

=item -p, --port I<NUM>

Default port to communicate on.

=item -n, --nick I<STRING>

Specify this node's name.
Default is the hostname.

=back

=head1 SEE ALSO

write(1), wall(1), rwall(1), rlwrap(1)

=cut

GetOptions(
	'B|broadcast-send!' => \$OptBroadcastSend,
	'b|broadcast-read!' => \$OptBroadcastRead,
	'multicast-addr=s' => \$OptMulticastAddr,
	'u|unicast=s@' => \@OptUnicast,
	'p|port=i' => \$OptPort,
	'n|nick=s' => \$OptNick,
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'<>' => sub { unshift @ARGV, @_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);



sub shout
{
	my $line = shift;
	my $meta = shift;
	my $only_senders = shift;
	
	$meta->{msgid} = uuidgen() unless exists $meta->{msgid};
	$meta->{nick} = $OptNick unless exists $meta->{nick};
	$sent_msgid{$meta->{msgid}} = 1;
	
	my $prepend = '';
	for my $metakey (keys %$meta)
	{
		$prepend .= $SOH . $metakey;
		$prepend .= '=' . $meta->{$metakey} if defined $meta->{$metakey};
	}
	$line = $prepend . $STX . $line;
	
	my $sent = 0;
	for my $writer (defined $only_senders ? @$only_senders : @net_writers)
	{
		if(ref $writer eq 'IO::Socket::Multicast')
		{
			for my $iface (network_interfaces())
			{
				if(eval { $writer->mcast_if($iface); 1 })
				{
					$writer->mcast_send($line, $mcast_dest);
					$sent++;
				}
				else
				{
					unless($!{EADDRNOTAVAIL} or $@ =~ /^interface is not multicast capable/)
					{
						warn "Could not set interface to $iface: $!: $@\n";
					}
				}
			}
		}
		else
		{
			if($writer->protocol == Socket::IPPROTO_TCP and not $writer->connected)
			{
			}
			else
			{
				$writer->send($line, 0);
				$sent++;
			}
		}
	}
	
	if($sent == 0)
	{
		warn "there was no working socket to send to.\n";
	}
}


$read_handles = IO::Select->new();
$connecting_handles = IO::Select->new();
$read_handles->add(\*STDIN);

if($OptBroadcastRead)
{
	my $bcast_reader = IO::Socket::INET->new(
		LocalPort => $OptPort,
		Proto	 => 'udp',
		ReuseAddr => 1,
		ReusePort => 1,
	) or die "Could not create broadcast receiver socket: $!\n";
	warn "broadcast receiver created\n";
	$read_handles->add($bcast_reader);
}

my $multicast_reader = IO::Socket::Multicast->new(
	LocalPort => $OptPort,
	Proto	 => 'udp',
	ReuseAddr => 1,
	ReusePort => 1,
) or die "Could not create multicast receiver socket: $!\n";
for my $local_ip (local_ipv4_addresses())
{
	unless($multicast_reader->mcast_add($OptMulticastAddr, $local_ip))
	{
		warn "Could not join to multicast group $OptMulticastAddr on local interface $local_ip: $!\n";
	}
}
warn "multicast receiver created\n";
$read_handles->add($multicast_reader);


# TODO support icmp listener
# TODO support raw ip listener
my $anycast_listener_udp = IO::Socket::INET->new(
	LocalAddr => '0.0.0.0',
	LocalPort => $OptPort,
	Proto	  => 'udp',
	ReuseAddr => 1,
	ReusePort => 1,
) or die "Could not create anycast receiver UDP socket: %s\n", $!;
warn "anycast udp receiver created\n";
push @net_listeners, $anycast_listener_udp;
$read_handles->add($anycast_listener_udp);

my $anycast_listener_tcp = IO::Socket::INET->new(
	LocalAddr => '0.0.0.0',
	LocalPort => $OptPort,
	Proto	  => 'tcp',
	Listen    => SOMAXCONN,
	ReuseAddr => 1,
	ReusePort => 1,
) or die "Could not create anycast receiver TCP socket: %s\n", $!;
warn "anycast tcp receiver created\n";
push @net_listeners, $anycast_listener_tcp;
$read_handles->add($anycast_listener_tcp);



@net_writers = ();
if($OptBroadcastSend)
{
	for my $local_ip (local_ipv4_addresses())
	{
		my $net_write = IO::Socket::INET->new(
			LocalAddr => $local_ip,
			PeerPort  => $OptPort,
			PeerAddr  => $broadcast_addr,
			Broadcast => 1,
			ReuseAddr => 1,
			ReusePort => 1,
			Proto	 => 'udp',
		) or warn "Could not create broadcast sender socket on local interface $local_ip: $!\n";
		next unless $net_write;
		warn "broadcast sender bound to local IP $local_ip\n";
		push @net_writers, $net_write;
	}
}

$mcast_dest = sockaddr_in($OptPort, inet_aton($OptMulticastAddr));
$multicast_write = IO::Socket::Multicast->new(
	LocalPort => $OptPort,
	Proto	 => 'udp',
	ReuseAddr => 1,
	ReusePort => 1,
) or warn "Could not create multicast sender socket: $!\n";
$multicast_write->mcast_loopback(0);
$multicast_write->mcast_add($OptMulticastAddr) or die "Could not join to multicast group $OptMulticastAddr: $!\n";
warn "multicast sender created\n";
push @net_writers, $multicast_write;


sub create_unicast_sender
{
	my $target = shift;
	my $io_socket_inet_params = shift || {};
	my ($addr, $port, $proto) = $target =~ m{^([^:/]+)(?::(\d+))?(?:/(tcp|udp))?$};
	if(not length $addr)
	{
		die "unknown target address '$target'\n";
	}
	# TODO support icmp, raw ip
	my $proto = lc $proto || 'udp';
	my $blocking = $proto eq 'tcp' ? 0 : 1;
	my $port = $port || $OptPort;
	my $canon_target = sprintf "%s:%d/%s", $addr, $port, $proto;
	
	my $sock = IO::Socket::INET->new(
		PeerAddr  => $addr,
		PeerPort  => $port,
		Proto	  => $proto,
		ReuseAddr => 1,
		ReusePort => 1,
		Blocking  => $blocking,
		%$io_socket_inet_params,
	) or warn sprintf "Could not create unicast sender %s socket: %s\n", $canon_target, $!;
	$unicast_senders{$target} = { target=>$target, canon_target=>$canon_target, addr=>$addr, port=>$port, proto=>$proto, protonum=>$sock->protocol, } unless exists $unicast_senders{$target};
	$unicast_senders{$target}->{sock} = $sock;
	if($proto eq 'tcp')
	{
		# connection-oriented sockets need to be connected first
		$connecting_handles->add($sock);
	}
	else
	{
		# connection-less sockets can be read right away
		push @net_writers, $sock;
		$read_handles->add($sock);
	}
	return $sock;
}

sub schedule_connect
{
	my $sender = shift;
	my $reconnect_interval_base = 2;
	my $reconnect_interval = $reconnect_interval_base * $sender->{reconnect_count};
	$sender->{scheduled_reconnect} = $sender->{end} + $reconnect_interval;
}

sub manage_poll_timeout
{
	my @schedules = sort {$a<=>$b} grep {defined} map {$_->{scheduled_reconnect}} values %unicast_senders;
	if(@schedules)
	{
		my $soonest = $schedules[0];
		$poll_timeout = $soonest - time;
		$poll_timeout = 0 if $poll_timeout <= 0;
	}
	else
	{
		$poll_timeout = undef;
	}
}

sub manage_reconnects
{
	for my $sender (values %unicast_senders)
	{
		if(defined $sender->{scheduled_reconnect} and $sender->{scheduled_reconnect} le time)
		{
			if(eval { create_unicast_sender($sender->{target}); 1; })
			{
				delete $sender->{scheduled_reconnect};
			}
			else
			{
				warn $@;
			}
		}
	}
}

%unicast_senders = ();
for my $target (@OptUnicast)
{
	eval { create_unicast_sender($target); 1; } or die $@;
	warn sprintf "unicast sender %s created\n", $unicast_senders{$target}->{canon_target};
}



%sent_msgid = ();
%received_msgid = ();
%nick_at_ip = ();
$prompt_was_erased = 1;
$poll_timeout = undef;
%unicast_back_senders = ();

shout(undef, {scan=>undef,});

while(1)
{
	print STDERR ">>> " if $prompt_was_erased and $read_handles->exists(\*STDIN);
	$prompt_was_erased = 0;
	
	manage_poll_timeout;
	my ($read_ready, $write_ready, undef) = IO::Select::select($read_handles, $connecting_handles, undef, $poll_timeout);
	manage_reconnects;
	
	for my $fh (@$write_ready)
	{
		my ($sender) = grep {;$_->{sock} eq $fh} values %unicast_senders;
		erase_prompt;
		$connecting_handles->remove($fh);
		
		$! = unpack('i', getsockopt($fh, SOL_SOCKET, SO_ERROR));
		if($!)
		{
			warn sprintf "can not connect to %s, error %d: %s\n", $sender->{canon_target}, $!, $!;
			$fh->close;
			
			# restart connection
			$sender->{end} = time;
			$sender->{reconnect_count}++;
			schedule_connect($sender);
		}
		else
		{
			# TCP connection established.
			warn sprintf "connected to %s\n", $sender->{canon_target};
			$sender->{reconnect_count} = 0;
			push @net_writers, $fh;
			$read_handles->add($fh);
			shout(undef, {scan=>undef,}, [$fh]);
		}
	}
	
	for my $fh (@$read_ready)
	{
		if ($fh eq \*STDIN)
		{
			my $line = <STDIN>;
			$prompt_was_erased = 1;
			unless(defined $line)
			{
				erase_prompt;
				$read_handles->remove(\*STDIN);
				next;
			}
			next if $line eq $/;
			shout($line, {});
		}
		else
		{
			if($fh->protocol == Socket::IPPROTO_TCP)
			{
				if(any {;$fh eq $_} @net_listeners)
				{
					# this is a TCP listener socket, receiving a new client.
					
					erase_prompt;
					if(my $connection = $fh->accept)
					{
						$connection->autoflush(1);
						warn sprintf "new connection from %s:%d on %s:%d/%s listener\n",
							$connection->peerhost, $connection->peerport,
							$connection->sockhost, $connection->sockport, protocolname($connection->protocol);
						push @net_writers, $connection;
						$read_handles->add($connection);
					}
					else
					{
						warn sprintf "can not accept connection on %s:%s/%s listener: %s\n", $fh->sockaddr, $fh->sockport, protocolname($fh->protocol), $!;
					}
					next;
				}
			}
			
			my $data;
			my $peer_ip;
			my $remote = $fh->recv($data, $max_msg_len);
			if($fh->protocol == Socket::IPPROTO_TCP)
			{
				$peer_ip = $fh->peerhost;
			}
			else
			{
				if(not defined $remote)
				{
					if($!{ECONNREFUSED})
					{
						my ($back_sender) = grep {;$_ eq $fh} values %unicast_back_senders;
						if(defined $back_sender)
						{
							# remove expired connection-less client
							$read_handles->remove($fh);
							delete $net_writers[first_index {$_ eq $fh} @net_writers];
							erase_prompt;
							warn sprintf "connection from %s:%d on %s:%d/%s listener closed\n",
								$fh->peerhost, $fh->peerport,
								$fh->sockhost, $fh->sockport, protocolname($fh->protocol);
							$fh->close;
						}
					}
					next;
				}
				
				my ($peerport, $peeraddr) = sockaddr_in($remote);
				$peer_ip = inet_ntoa($peeraddr);
				
				# add connection-less unicast peer if it is not there yet:
				if(not grep {$_->{addr} eq $peer_ip and $_->{port} eq $peerport and $_->{protonum} eq $fh->protocol} values %unicast_senders)
				{
					my $proto = lc protocolname($fh->protocol);
					my $target = "$peer_ip:$peerport/$proto";
					erase_prompt;
					if(eval { create_unicast_sender($target, {LocalPort=>$fh->sockport}); 1; }) {
						warn sprintf "unicast sender %s created\n", $unicast_senders{$target}->{canon_target};
						$unicast_back_senders{$target} = $unicast_senders{$target}->{sock};
					}
					else { warn $@; }
				}
			}
			
			if($fh->protocol == Socket::IPPROTO_TCP and not length $data)
			{
				# this is TCP client connection (accepted or initiated) closed the connection.
				# if an accepted connection got closed, just drop it.
				# if an initiated connection got closed, restart it.
				
				my ($sender) = grep {;$_->{sock} eq $fh} values %unicast_senders;
				
				$read_handles->remove($fh);
				delete $net_writers[first_index {$_ eq $fh} @net_writers];
				erase_prompt;
				
				if(defined $sender)
				{
					warn sprintf "unicast sender %s:%d/%s closed\n",
						$fh->peerhost, $fh->peerport, protocolname($fh->protocol);
				}
				else
				{
					warn sprintf "connection from %s:%d on %s:%d/%s listener closed\n",
						$fh->peerhost, $fh->peerport,
						$fh->sockhost, $fh->sockport, protocolname($fh->protocol);
				}
				$fh->close;
				
				if(defined $sender)
				{
					# restart TCP unicast sender
					$sender->{end} = time;
					schedule_connect($sender);
				}
				
				next;
			}
			
			my %metadata = ();
			while($data =~ s/^\x01([^=\x00-\x1F]+)(?:=([^\x01\x02]*))?//)
			{
				$metadata{$1} = $2;
			}
			
			my $msgid = $metadata{msgid} // uuidgen();
			next if exists $sent_msgid{$msgid};
			my $nick = $metadata{nick};
			my $nickprint = $nick || '(anon)';
			
			if(not $peer_ip ~~ [keys %nick_at_ip])
			{
				erase_prompt;
				printf "%s is at %s\n", $nickprint, $peer_ip;
			}
			
			if(exists $nick_at_ip{$peer_ip} and $nick_at_ip{$peer_ip} ne $nick)
			{
				erase_prompt;
				printf "%s is transmitting from %s instead of %s\n", $nickprint, $peer_ip, $nick_at_ip{$peer_ip} || '(anon)';
			}
			$nick_at_ip{$peer_ip} = $nick;
			
			next if exists $received_msgid{$msgid};
			$received_msgid{$msgid} = 1 if defined $metadata{msgid};  # remember this message only if the sender set the msgid, not us.
			
			$data =~ s/^\x02//;
			$data =~ s/$LF$//;
			if(length $data)
			{
				$data =~ s/[\x00-\x1F\x7F]/my $c = ord $&; sprintf "\x1B[7m^%c\x1B[27m", $c < 0x60 ? $c+0x40 : $c-0x40/eg;
				erase_prompt;
				printf "%s >>> %s\n", $nick || $peer_ip, $data;
			}
			
			if(exists $metadata{scan})
			{
				shout(undef, {present=>1,});
			}
		}
	}
}
