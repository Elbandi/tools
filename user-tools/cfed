#!/usr/bin/env perl

=pod

=head1 NAME

cfed - Command File-Editor - Edit text files by commands directly from shell

=head1 SYNOPSIS

 cfed [<OPTIONS>] <INSTRUCTIONS> [-- <FILE> [<FILE> [...]]]

=head1 OPTIONS

=over 4

=item -c, --confirm

=item -v, --verbose

=back

=cut

use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case bundling pass_through/;
use feature qw/switch/;
use Pod::Usage;
# Term::ReadLine::Gnu is recommended
$readline_support = eval q{ use Term::ReadLine; 1; };
use POSIX;

$0 =~ s/.*\/([^\/]+)$/$1/;
$OptConfirm = 0;
$OptVerbose = 0;

GetOptions(
	'c|confirm' => \$OptConfirm,
	'v|verbose' => \$OptVerbose,
) or exit 2;


# instruction token ending regexp
my $EOIT = qr/(\s+|$)/;
my $blockio_buffer_size = 4096;



sub verbose
{
	my $msg = shift;
	if($OptVerbose)
	{
		warn "$0: $msg\n";
	}
}

sub get_text_parameter
{
	my $params_ref = shift;
	my $text = undef;
	if($$params_ref =~ s/^([""''])(.*?)(?<!\\)(?1)$EOIT//)
	{
		my ($q, $text) = ($1, $2);
		$text =~ s/\\($q)/$1/g;
		# TODO robust escaping
	}
	elsif($$params_ref =~ s/^([^""'']\S*)$EOIT//)   { $text = $1; }
	return $text;
}

sub get_pattern_parameter
{
	my $params_ref = shift;
	my $pattern = get_text_parameter($params_ref);
	my $is_regexp = 0;
	if($pattern =~ m{^/(.*)/([a-zA-Z]*)$})
	{
		$pattern = "(?$2)$1";
		$is_regexp = 1;
	}
	return ($pattern, $is_regexp);
}

sub overwrite_text
{
	my $fdata = shift;
	my $text = shift;
	print {$fdata->{'handle'}} $text or die "$0: $fdata->{'path'}: write: $!\n";
}

sub seeker
{
	my $fdata = shift;
	my $offset = shift;
	my $whence = shift;
	seek $fdata->{'handle'}, $offset, $whence or die "$0: $fdata->{'path'}: seek: $!\n";
}

sub readblock
{
	my $fdata = shift;
	my $scalar_ref = shift;
	my $blocksize = shift || $blockio_buffer_size;
	my $bytes = read $fdata->{'handle'}, $$scalar_ref, $blocksize;
	die "$0: $fdata->{'path'}: read: $!\n" unless defined $bytes;
	return $bytes;
}

sub insert_text
{
	my $fdata = shift;
	my $text = shift;
	
	my $original_pos = tell $fdata->{'handle'};
	my $buffer;
	my $tail = $text;
	# FIXME tail >= length buffer ?
	my $pos = $original_pos;
	while(readblock $fdata, \$buffer)
	{
		seeker $fdata, $pos, SEEK_SET;
		print {$fdata->{'handle'}} $tail or die "$0: $fdata->{'path'}: write: $!\n";
		print {$fdata->{'handle'}} substr $buffer, 0, -length$tail or die "$0: $fdata->{'path'}: write: $!\n";
		$tail = substr $buffer, -length$tail;
		$pos = tell $fdata->{'handle'};
	}
	print {$fdata->{'handle'}} $tail or die "$0: $fdata->{'path'}: write: $!\n";
	seek $fdata->{'handle'}, $original_pos + length($text), SEEK_SET;
	# TODO maintain %mark marks
}

sub delete_chars
{
	my $fdata = shift;
	my $length = shift;
	
	my $original_pos = tell $fdata->{'handle'};
	my $buffer;
	my $continue_write_pos = $original_pos;
	seeker $fdata, $length, SEEK_CUR;
	while(readblock $fdata, \$buffer)
	{
		seeker $fdata, $continue_write_pos, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or die "$0: $fdata->{'path'}: write: $!\n";
		$continue_write_pos = tell $fdata->{'handle'};
		seeker $fdata, $length, SEEK_CUR;
	}
	truncate $fdata->{'handle'}, $continue_write_pos;
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain %mark marks
}

sub search_pattern
{
	my $fdata = shift;
	my $pattern = shift;
	my $is_regexp = shift;
	
	my $original_pos = tell $fdata->{'handle'};
	my $chunk_start_pos = $original_pos;
	my $found_pos = undef;
	my $matched_string;
	
	while(my $chunk = readline $fdata->{'handle'})
	{
		if($is_regexp)
		{
			if($chunk =~ $pattern)
			{
				$found_pos = $chunk_start_pos + length $`;
				$matched_string = $&;
			}
		}
		else
		{
			my $index = index $chunk, $pattern;
			if($index >= 0)
			{
				$found_pos = $chunk_start_pos + $index;
				$matched_string = $pattern;
			}
		}
		last if defined $found_pos;
		$chunk_start_pos = tell $fdata->{'handle'};
	}
	
	seeker $fdata, $original_pos, SEEK_SET;
	
	return ($found_pos, $matched_string);
}

sub process_instructions
{
	my $fdata = {'path' => shift,};
	my $instructions = shift;
	
	my $last_search_pattern = undef;
	my $last_search_is_regexp = undef;
	my $last_search_result = undef;
	my %mark = ();
	my $clipboard = '';
	my $selection_start = undef;
	my $selection_stop = undef;
	
	open $fdata->{'handle'}, '+<', $fdata->{'path'} or die "$0: $fdata->{'path'}: open: $!\n";
	
	while(1)
	{
		my $position_before_operation = tell $fdata->{'handle'};
		$instructions =~ s/^\s*//;
=pod

=head1 EDITOR INSTRUCTIONS

=over 4

=cut
		if($instructions =~ s/^goto$EOIT//)
		{
			my $goto_pos = undef;
			my $whence = SEEK_SET;
=pod

=item goto end of [last] search result

=cut
			if($instructions =~ s/^end of( last)? search result$EOIT//)
			{
				my $c = $last_search_is_regexp ? '/' : '"';
				die "$0: last search ($c$last_search_pattern$c) was not found\n" if not defined $last_search_result;
				$goto_pos = $last_search_result_pos + 1 + length $last_search_result;
			}
=pod

=item goto [start | end] [of file]

=item goto [start | end] of line

=cut
			elsif($instructions =~ s/^(?<ANCHOR>start|end)( of (?<SCOPE>file|line))?$EOIT//)
			{
				if($+{'SCOPE'} eq 'line')
				{
					if($+{'ANCHOR'} eq 'end')
					{
						my $rest_of_line = readline $fdata->{'handle'};
						if(substr $rest_of_line, -1 eq "\n")
						{
							seeker $fdata, -1, SEEK_CUR;
						}
					}
					else  # start
					{
						my $buffer;
						my $pos = $position_before_operation;
						while($pos != 0)
						{
							if($pos < $blockio_buffer_size)
							{
								seeker $fdata, 0, SEEK_SET;
								readblock $fdata, \$buffer, $pos;
								$pos = 0;
							}
							else
							{
								seeker $fdata, $blockio_buffer_size, SEEK_CUR;
								$pos = tell $fdata->{'handle'};
								readblock $fdata, \$buffer;
							}
							my $idx = rindex $buffer, "\n";
							if($idx >= 0)
							{
								$goto_pos = $pos + $idx + 1;
								last;
							}
							seeker $fdata, $pos, SEEK_SET;
						}
					}
				}
				else  # file
				{
					$goto_pos = 0;
					$whence = $+{'ANCHOR'} eq 'start' ? SEEK_SET : SEEK_END;
				}
			}
=pod

=item goto [previous | next] line

=cut
			elsif($instructions =~ s/^(?<DIRECTION>next|previous) line$EOIT//)
			{
				if($+{'DIRECTION'} eq 'next')
				{
					readline $fdata->{'handle'};
				}
				else  # previous
				{
					# TODO
				}
			}
=pod

=item goto [back | forward] COUNT line[s]

=cut
			elsif($instructions =~ s/^(?<DIRECTION>back|forward) (?<COUNT>[1-9]\d*) lines?$EOIT//)
			{
				if($+{'DIRECTION'} eq 'forward')
				{
					readline $fdata->{'handle'} for 1..$+{'COUNT'};
				}
				else  # back
				{
					# TODO
				}
			}
=pod

=item goto line NUMBER

Lines are indexed by 0.

=item go [up | down]

=cut
			elsif($instructions =~ s/^line (?<COUNT>\d*)$EOIT//)
			{
				seeker $fdata, 0, SEEK_SET;
				readline $fdata->{'handle'} for 1..$+{'COUNT'};
			}
=pod

=item goto mark NAME

Set cursor position in file.

=cut
			elsif($instructions =~ s/^mark (\S+)$EOIT//)
			{
				my $mark = $1;
				die "$0: $fdata->{'path'}: mark $mark not found\n" if not exists $mark{$mark};
				$goto_pos = $mark{$mark};
			}
			else
			{
				die "$0: invalid GOTO: $instructions\n";
			}
			
			if(defined $goto_pos)
			{
				seeker $fdata, $goto_pos, $whence;
			}
		}
=pod

=item type STRING

Insert given STRING into the current cursor position.

=cut
		elsif($instructions =~ s/^type$EOIT//)
		{
			my $text = get_text_parameter \$instructions;
			die "$0: text not given to type in\n" unless defined $text;
			insert_text $fdata, $text;
			verbose sprintf "%s: inserted %d bytes at %d", $fdata->{'path'}, length $text, $position_before_operation;
		}
=pod

=item overwrite with STRING

=item overtype with STRING

Type given STRING into the current cursor position in overwrite mode.

=cut
		elsif($instructions =~ s/^over(write|type) with$EOIT//)
		{
			my $text = get_text_parameter \$instructions;
			die "$0: text not given to overwrite with\n" unless defined $text;
			overwrite_text $fdata, $text;
			verbose sprintf "%s: written over %d bytes at %d", $fdata->{'path'}, length $text, $position_before_operation;
		}
=pod

=item replace all [[occurrences of] PATTERN] to STRING

=item replace all [occurrences | PATTERN] to STRING

=item replace [next [COUNT]] [[occurrence[s] of] PATTERN] to STRING

=item replace [next [COUNT]] [occurrence[s] | PATTERN] to STRING

Replace given PATTERN to STRING.
If PATTERN is not given, then the last search pattern will be used.
"Replace next" changes only the next COUNT number of occurrences
starting from the cursor position.
Default is 1 occurrence, if COUNT is not given.
"Replace all" changes all the occurrences from the cursor position down
to the end of file.
If you want to replace all the occurrences in the whole file,
"goto start" first.

=cut
		elsif($instructions =~ s/^replace( (?<LIMIT>all|next( (?<COUNT>[1-9]\d*)|))|)(?<OCCUR> occurrences?(?<OF> of|)|)$EOIT//)
		{
			die "$0: don't understand this REPLACE instruction\n" if not $+{'LIMIT'} and $+{'OCCUR'};
			my $replace_count = $+{'LIMIT'} eq 'all' ? undef : ($+{'COUNT'}||1);
			my $expect_pattern;
			$expect_pattern = 1 if $+{'OF'};
			$expect_pattern = 0 if $+{'OCCUR'} and not $+{'OF'};
			my $pattern;
			my $is_regexp = 0;
			my $text;
			
			if((not defined $expect_pattern and $instructions !~ /^to$EOIT/) or $expect_pattern eq 1)
			{
				($pattern, $is_regexp) = get_pattern_parameter \$instructions;
				die "$0: string/pattern not given what to replace\n" unless length $pattern;
			}
			else  # not expecting PATTERN to be given here
			{
				$pattern = $last_search_pattern;
				$is_regexp = $last_search_is_regexp;
			}
			
			if($instructions =~ s/^to$EOIT//)
			{
				$text = get_text_parameter \$instructions;
			}
			die "$0: string not given to replace pattern to\n" unless defined $text;
			
			my $replacements = 0;
			
			while(not defined $replace_count or $replace_count > 0)
			{
				my ($found_pos, $matched_string) = search_pattern $fdata, $pattern, $is_regexp;
				
				if(defined $found_pos)
				{
					seeker $fdata, $found_pos, SEEK_SET;
					my $found_length = length $matched_string;
					my $length_to_delete = $found_length - length $text;
					if($length_to_delete >= 0)
					{
						delete_chars $fdata, $length_to_delete if $length_to_delete > 0;
						overwrite_text $fdata, $text;
					}
					else
					{
						overwrite_text $fdata, substr($text, 0, $found_length);
						insert_text $fdata, substr($text, $found_length);
					}
					verbose "$fdata->{'path'}: replaced \"$matched_string\" to \"$text\" at $found_pos";
					$replace_count -= 1 if defined $replace_count;
					$replacements += 1;
				}
				else
				{
					last;
				}
			}
			
			verbose "$fdata->{'path'}: replaced $replacements occurrences";
		}
=pod

=item search PATTERN [backward]

Find next occurrence (or previous one if "backward" is specified) of
PATTERN and set the cursor to it.
PATTERN is either a bare word, a string enclosed in quotes, or a regexp
enclosed in slashes (C</regexp/>).
PATTERN is not supported to overhang from one line to the next.
Remove newlines from the text if you must.

=cut
		elsif($instructions =~ s/^search$EOIT//)
		{
			my ($pattern, $is_regexp) = get_pattern_parameter(\$instructions);
			die "$0: string/pattern not given what to search for\n" unless length $pattern;
			
			# TODO search backward
			my ($found_pos, $matched_string) = search_pattern $fdata, $pattern, $is_regexp;
			
			if(defined $found_pos)
			{
				seeker $fdata, $found_pos, SEEK_SET;
			}
			$last_search_pattern = $pattern;
			$last_search_is_regexp = $is_regexp;
			$last_search_result_pos = $found_pos;
			$last_search_result = $matched_string;
		}
=pod

=item mark as NAME

=cut
		elsif($instructions =~ s/^mark as (\S+)$EOIT//)
		{
			$mark{$1} = $position_before_operation;
		}
=pod

=item select from mark START-MARK to mark END-MARK

=cut
		elsif($instructions =~ s/^select from mark (\S+) to mark (\S+)$EOIT//)
		{
			$selection_start = undef;
			$selection_stop = undef;
			if(not exists $mark{$1}) { verbose "$fdata->{'path'}: mark $1 not found"; }
			elsif(not exists $mark{$2}) { verbose "$fdata->{'path'}: mark $2 not found"; }
			else {
				$selection_start = $mark{$1};
				$selection_stop  = $mark{$2};
			}
		}
=pod

=item select [COUNT] [char[s] | word[s] | line[s]]

=item copy

=item cut

=item paste

=item insert file FILE

=item insert output of COMMAND;

=item filter through COMMAND;

=item send to COMMAND;

=item uppercase

=item lowercase

=item capitalize

=cut
		elsif($instructions =~ s/^(uppercase|lowercase|capitalize)$EOIT//)
		{
			if($selection_start)
			{
				seeker $fdata, $selection_start, SEEK_SET;
				# TODO
			}
			else
			{
				verbose "$fdata->{'path'}: there is not any selection";
			}
		}
		elsif($instructions eq '')
		{
			last;
		}
		else
		{
			die "$0: invalid instruction: $instructions\n";
		}
	}

=pod

=back

=cut

	close $fdata->{'handle'} or die "$0: $fdata->{'path'}: close: $!\n";
}


while(scalar @ARGV)
{
	my $arg = shift @ARGV;
	if($arg eq '--')
	{
		push @Files, @ARGV;
		last;
	}
	push @Instructions, $arg;
}

$Instructions = join ' ', map { if(/[ ]/ or $_ eq ''){ s/[""]/\\$&/g; $_="\"$_\""; }; $_ } @Instructions;
$Instructions =~ s/\s+/ /;
$Instructions =~ s/\s*$//;

die "$0: not any editing instructions given\n" unless $Instructions;
die "$0: not any files given\n" unless @Files;

#warn Dumper $Instructions;

# TODO optional backup files

for my $Filepath (@Files)
{
	process_instructions $Filepath, $Instructions;
}
