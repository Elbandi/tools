#!/usr/bin/env perl

=pod

=head1 NAME

cfed - Command File-Editor - Edit text files by commands directly from shell

=head1 SYNOPSIS

 cfed [<OPTIONS>] <INSTRUCTIONS>

=head1 OPTIONS

=over 4

=item -c, --confirm

=item -v, --verbose

=back

=cut

use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case bundling pass_through/;
use feature qw/switch/;
use Pod::Usage;
# Term::ReadLine::Gnu is recommended
$readline_support = eval q{ use Term::ReadLine; 1; };
use POSIX;
use Carp qw/croak/;

$0 =~ s/.*\/([^\/]+)$/$1/;
$OptConfirm = 0;
$OptVerbose = 0;

GetOptions(
	'c|confirm' => \$OptConfirm,
	'v|verbose' => \$OptVerbose,
) or exit 2;


# instruction token ending regexp
my $EOIT = qr/([ ]+|$)/;
my $blockio_buffer_size = 4096;



sub verbose
{
	my $msg = shift;
	if($OptVerbose)
	{
		warn "$0: $msg\n";
	}
}

sub get_text_parameter
{
	my $params_ref = shift;
	my $text = undef;
	if($$params_ref =~ s/^([""''])(.*?)(?<!\\)(?1)$EOIT//)
	{
		my $q = $1;
		$text = $2;
		$text =~ s/\\($q)/$1/g;
		# TODO robust escaping
	}
	elsif($$params_ref =~ s/^([^""'']\S*)$EOIT//)   { $text = $1; }
	return $text;
}

sub get_pattern_parameter
{
	my $params_ref = shift;
	my $pattern = get_text_parameter($params_ref);
	my $is_regexp = 0;
	if($pattern =~ m{^/(.*)/([a-zA-Z]*)$})
	{
		$pattern = "(?$2)$1";
		$is_regexp = 1;
	}
	return ($pattern, $is_regexp);
}

sub seeker
{
	my $fdata = shift;
	my $offset = shift;
	my $whence = shift;
	seek $fdata->{'handle'}, $offset, $whence or croak "$0: $fdata->{'path'}: seek: $!";
}

sub readblock
{
	my $fdata = shift;
	my $scalar_ref = shift;
	my $blocksize = shift || $blockio_buffer_size;
	my $bytes = read $fdata->{'handle'}, $$scalar_ref, $blocksize;
	croak "$0: $fdata->{'path'}: read: $!" unless defined $bytes;
	return $bytes;
}

sub overwrite_text
{
	my $fdata = shift;
	my $text = shift;
	print {$fdata->{'handle'}} $text or croak "$0: $fdata->{'path'}: write: $!";
}

sub make_room
{
	my $fdata = shift;
	my $room_size = shift;
	
	my $buffer;
	my $original_pos = tell $fdata->{'handle'};
	seeker $fdata, 0, SEEK_END;
	
	while(1)
	{
		my $curpos = tell $fdata->{'handle'};
		my $chunk_size = $curpos - $original_pos;
		last if $chunk_size <= 0;
		$chunk_size = $blockio_buffer_size if $chunk_size > $blockio_buffer_size;
		seeker $fdata, -$chunk_size, SEEK_CUR;
		my $bytes = readblock $fdata, \$buffer, $chunk_size;
		croak sprintf "%s: %s: can not read %d bytes at %d", $0, $fdata->{'path'}, $chunk_size, $curpos-$chunk_size if $bytes != $chunk_size;
		seeker $fdata, $curpos + $room_size - $chunk_size, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or croak "$0: $fdata->{'path'}: write: $!";
		seeker $fdata, $curpos-$chunk_size, SEEK_SET;
	}
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain $fdata->{'mark'} marks
}

sub insert_text
{
	my $fdata = shift;
	my $text = shift;
	make_room $fdata, length $text;
	return overwrite_text $fdata, $text;
}

sub find_size
{
	my $fdata = shift;
	return if defined $fdata->{'size'};
	
	my $pos = tell $fdata->{'handle'};
	seek $fdata->{'handle'}, 0, SEEK_END;
	if($! == 0)
	{
		$fdata->{'size'} = tell $fdata->{'handle'};
	}
	seek $fdata->{'handle'}, $pos, SEEK_SET;
}

sub insert_stream
{
	my $fdata = shift;
	my $stream_data = shift;
	find_size $stream_data;
	
	my $buffer;
	my $room_allocated = 0;
	if(defined $stream_data->{'size'})
	{
		make_room $fdata, $stream_data->{'size'};
		$room_allocated = 1;
	}
	while(my $bytes = readblock $stream_data, \$buffer)
	{
		if($room_allocated) { overwrite_text $fdata, $buffer; }
		else                { insert_text $fdata, $buffer; }
	}
}

sub delete_chars
{
	my $fdata = shift;
	my $length = shift;
	
	my $original_pos = tell $fdata->{'handle'};
	my $buffer;
	my $continue_write_pos = $original_pos;
	seeker $fdata, $length, SEEK_CUR;
	while(readblock $fdata, \$buffer)
	{
		seeker $fdata, $continue_write_pos, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or croak "$0: $fdata->{'path'}: write: $!";
		$continue_write_pos = tell $fdata->{'handle'};
		seeker $fdata, $length, SEEK_CUR;
	}
	truncate $fdata->{'handle'}, $continue_write_pos;
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain $fdata->{'mark'} marks
}

sub search_pattern
{
	my $fdata = shift;
	my $pattern = shift;
	my $is_regexp = shift;
	
	my $original_pos = tell $fdata->{'handle'};
	my $chunk_start_pos = $original_pos;
	my $found_pos = undef;
	my $matched_string;
	
	while(my $chunk = readline $fdata->{'handle'})
	{
		if($is_regexp)
		{
			if($chunk =~ $pattern)
			{
				$found_pos = $chunk_start_pos + length $`;
				$matched_string = $&;
			}
		}
		else
		{
			my $index = index $chunk, $pattern;
			if($index >= 0)
			{
				$found_pos = $chunk_start_pos + $index;
				$matched_string = $pattern;
			}
		}
		last if defined $found_pos;
		$chunk_start_pos = tell $fdata->{'handle'};
	}
	
	seeker $fdata, $original_pos, SEEK_SET;
	
	return ($found_pos, $matched_string);
}

sub process_instructions
{
	my $instructions = shift;
	
	my %openedfile = ();
	my %filepathalias = ();
	my $curfile;
	
	my $last_search_pattern = undef;
	my $last_search_is_regexp = undef;
	my $last_search_result = undef;
	my $clipboard = '';
	
	while(1)
	{
		my $position_before_operation;
		$position_before_operation = tell $curfile->{'handle'} if $curfile;
		$instructions =~ s/^\s*//;
=pod

=head1 EDITOR INSTRUCTIONS

=over 4

=item open [or create] PATH [as NAME]

=item open NAME

Open PATH file to edit.
You can switch between multiple opened files by invoking C<open PATH>
again,
or C<open NAME> if you opened that file under a certain NAME by
C<as NAME>.
You can not open a file on path NAME once you set NAME as an alias for
an other PATH.
But you cat always refer to the same path by prepending C<./> (or C</>
in case of absolute paths) to it.
Don't worry, it won't open the same PATH multiple time with conflicting
editor states.
You have to open a file before any other operation.

=cut
		if($instructions =~ s/^open$EOIT//)
		{
			my $may_create = 0;
			if($instructions =~ s/^or create$EOIT//)
			{
				$may_create = 1;
			}
			
			my $key = get_text_parameter \$instructions;
			croak "$0: file path or alias expected to open" unless length $key;
			
			my $alias;
			if($instructions =~ s/^as (\S+)$EOIT//)
			{
				$alias = $1;
			}
			
			my $path;
			if(not defined $alias)
			{
				# "open NAME" form -> check aliases
				if(exists $filepathalias{$key})
				{
					$path = $filepathalias{$key};
				}
			}
			if(not defined $path)
			{
				# either "open NAME" form and NAME alias is not found,
				# or "open PATH" or "open PATH as NAME" form
				$path = $key;
			}
			if(not exists $openedfile{$path})
			{
				# file is not yet open
				my $handle;
				if($may_create)
				{
					use Fcntl;
					sysopen $handle, $path, O_RDWR|O_CREAT or croak "$0: $path: open: $!";
				}
				else
				{
					open $handle, '+<', $path or croak "$0: $path: open: $!";
				}
				$openedfile{$path} = {'handle' => $handle, 'path' => $path};
				verbose sprintf "%s: opened%s", $path, defined $alias ? " as $alias" : "";
			}
			$curfile = $openedfile{$path};
			$filepathalias{$alias} = $path if defined $alias;
		}
		elsif($instructions =~ s/^goto$EOIT//)
		{
			my $goto_pos = undef;
			my $whence = SEEK_SET;
=pod

=item goto end of [last] search result

=cut
			if($instructions =~ s/^end of( last)? search result$EOIT//)
			{
				my $c = $last_search_is_regexp ? '/' : '"';
				croak "$0: last search ($c$last_search_pattern$c) was not found" if not defined $last_search_result;
				$goto_pos = $last_search_result_pos + 1 + length $last_search_result;
			}
=pod

=item goto [start | end] [of file]

=item goto [start | end] of line

=cut
			elsif($instructions =~ s/^(?<ANCHOR>start|end)( of (?<SCOPE>file|line))?$EOIT//)
			{
				if($+{'SCOPE'} eq 'line')
				{
					if($+{'ANCHOR'} eq 'end')
					{
						my $rest_of_line = readline $curfile->{'handle'};
						if(substr $rest_of_line, -1 eq "\n")
						{
							seeker $curfile, -1, SEEK_CUR;
						}
					}
					else  # start
					{
						my $buffer;
						my $pos = $position_before_operation;
						while($pos != 0)
						{
							if($pos < $blockio_buffer_size)
							{
								seeker $curfile, 0, SEEK_SET;
								readblock $curfile, \$buffer, $pos;
								$pos = 0;
							}
							else
							{
								seeker $curfile, $blockio_buffer_size, SEEK_CUR;
								$pos = tell $curfile->{'handle'};
								readblock $curfile, \$buffer;
							}
							my $idx = rindex $buffer, "\n";
							if($idx >= 0)
							{
								$goto_pos = $pos + $idx + 1;
								last;
							}
							seeker $curfile, $pos, SEEK_SET;
						}
					}
				}
				else  # file
				{
					$goto_pos = 0;
					$whence = $+{'ANCHOR'} eq 'start' ? SEEK_SET : SEEK_END;
				}
			}
=pod

=item goto [previous | next] line

=cut
			elsif($instructions =~ s/^(?<DIRECTION>next|previous) line$EOIT//)
			{
				if($+{'DIRECTION'} eq 'next')
				{
					readline $curfile->{'handle'};
				}
				else  # previous
				{
					# TODO
				}
			}
=pod

=item goto [back | forward] COUNT line[s]

=cut
			elsif($instructions =~ s/^(?<DIRECTION>back|forward) (?<COUNT>[1-9]\d*) lines?$EOIT//)
			{
				if($+{'DIRECTION'} eq 'forward')
				{
					readline $curfile->{'handle'} for 1..$+{'COUNT'};
				}
				else  # back
				{
					# TODO
				}
			}
=pod

=item goto [line | char] index NUMBER

Lines and char offsets are indexed by 0.

=cut
			elsif($instructions =~ s/^(?<WHAT>line|char) index (?<COUNT>\d*)$EOIT//)
			{
				seeker $curfile, 0, SEEK_SET;
				readline $curfile->{'handle'} for 1..$+{'COUNT'};
				# TODO: char index ...
			}
=pod

=item goto mark NAME

Set cursor position in file.

=cut
			elsif($instructions =~ s/^mark (\S+)$EOIT//)
			{
				my $mark = $1;
				croak "$0: $curfile->{'path'}: mark $mark not found" if not exists $curfile->{'mark'}->{$mark};
				$goto_pos = $curfile->{'mark'}->{$mark};
			}
			else
			{
				croak "$0: invalid GOTO: $instructions";
			}
			
			if(defined $goto_pos)
			{
				seeker $curfile, $goto_pos, $whence;
			}
		}
=pod

=item go [up | down | left | right] [COUNT times]

=cut
		elsif($instructions =~ s/^go (?<WHERE>up|down|left|right)( (?<COUNT>\d*) times|)$EOIT//)
		{
			# TODO
		}
=pod

=item type STRING

=item enter STRING

Insert given STRING into the current cursor position.
Add newline to the end only if called as c<enter>.

=cut
		elsif($instructions =~ s/^(type|enter)$EOIT//)
		{
			my $end = $1 eq 'enter' ? "\n" : "";
			my $text = get_text_parameter \$instructions;
			croak "$0: text not given to type in" unless defined $text;
			insert_text $curfile, $text.$end;
			verbose sprintf "%s: inserted %d bytes at %d", $curfile->{'path'}, length $text, $position_before_operation;
		}
=pod

=item overwrite with STRING

=item overtype with STRING

Type given STRING into the current cursor position in overwrite mode.

=cut
		elsif($instructions =~ s/^over(write|type) with$EOIT//)
		{
			my $text = get_text_parameter \$instructions;
			croak "$0: text not given to overwrite with" unless defined $text;
			overwrite_text $curfile, $text;
			verbose sprintf "%s: written over %d bytes at %d", $curfile->{'path'}, length $text, $position_before_operation;
		}
=pod

=item replace all [[occurrences of] PATTERN] to STRING

=item replace all [occurrences | PATTERN] to STRING

=item replace [next [COUNT]] [[occurrence[s] of] PATTERN] to STRING

=item replace [next [COUNT]] [occurrence[s] | PATTERN] to STRING

Replace given PATTERN to STRING.
If PATTERN is not given, then the last search pattern will be used.
"Replace next" changes only the next COUNT number of occurrences
starting from the cursor position.
Default is 1 occurrence, if COUNT is not given.
"Replace all" changes all the occurrences from the cursor position down
to the end of file.
If you want to replace all the occurrences in the whole file,
"goto start" first.

=cut
		elsif($instructions =~ s/^replace( (?<LIMIT>all|next( (?<COUNT>[1-9]\d*)|))|)(?<OCCUR> occurrences?(?<OF> of|)|)$EOIT//)
		{
			croak "$0: don't understand this REPLACE instruction" if not $+{'LIMIT'} and $+{'OCCUR'};
			my $replace_count = $+{'LIMIT'} eq 'all' ? undef : ($+{'COUNT'}||1);
			my $expect_pattern;
			$expect_pattern = 1 if $+{'OF'};
			$expect_pattern = 0 if $+{'OCCUR'} and not $+{'OF'};
			my $pattern;
			my $is_regexp = 0;
			my $text;
			
			if((not defined $expect_pattern and $instructions !~ /^to$EOIT/) or $expect_pattern eq 1)
			{
				($pattern, $is_regexp) = get_pattern_parameter \$instructions;
				croak "$0: string/pattern not given what to replace" unless length $pattern;
			}
			else  # not expecting PATTERN to be given here
			{
				$pattern = $last_search_pattern;
				$is_regexp = $last_search_is_regexp;
			}
			
			if($instructions =~ s/^to$EOIT//)
			{
				$text = get_text_parameter \$instructions;
			}
			croak "$0: string not given to replace pattern to" unless defined $text;
			
			my $replacements = 0;
			
			while(not defined $replace_count or $replace_count > 0)
			{
				my ($found_pos, $matched_string) = search_pattern $curfile, $pattern, $is_regexp;
				
				if(defined $found_pos)
				{
					seeker $curfile, $found_pos, SEEK_SET;
					my $found_length = length $matched_string;
					my $length_to_delete = $found_length - length $text;
					if($length_to_delete >= 0)
					{
						delete_chars $curfile, $length_to_delete if $length_to_delete > 0;
						overwrite_text $curfile, $text;
					}
					else
					{
						overwrite_text $curfile, substr($text, 0, $found_length);
						insert_text $curfile, substr($text, $found_length);
					}
					verbose "$curfile->{'path'}: replaced \"$matched_string\" to \"$text\" at $found_pos";
					$replace_count -= 1 if defined $replace_count;
					$replacements += 1;
				}
				else
				{
					last;
				}
			}
			
			verbose "$curfile->{'path'}: replaced $replacements occurrences";
		}
=pod

=item search PATTERN [backward]

Find next occurrence (or previous one if "backward" is specified) of
PATTERN and set the cursor to it.
PATTERN is either a bare word, a string enclosed in quotes, or a regexp
enclosed in slashes (C</regexp/>).
PATTERN is not supported to overhang from one line to the next.
Remove newlines from the text if you must.

=cut
		elsif($instructions =~ s/^search$EOIT//)
		{
			my ($pattern, $is_regexp) = get_pattern_parameter(\$instructions);
			croak "$0: string/pattern not given what to search for" unless length $pattern;
			
			# TODO search backward
			my ($found_pos, $matched_string) = search_pattern $curfile, $pattern, $is_regexp;
			
			if(defined $found_pos)
			{
				seeker $curfile, $found_pos, SEEK_SET;
			}
			$last_search_pattern = $pattern;
			$last_search_is_regexp = $is_regexp;
			$last_search_result_pos = $found_pos;
			$last_search_result = $matched_string;
		}
=pod

=item mark as NAME

=cut
		elsif($instructions =~ s/^mark as (\S+)$EOIT//)
		{
			$curfile->{'mark'}->{$1} = $position_before_operation;
		}
=pod

=item select from START-MARK to END-MARK

=cut
		elsif($instructions =~ s/^select from (\S+) to (\S+)$EOIT//)
		{
			$curfile->{'mark'}->{'SELECTION_START'} = undef;
			$curfile->{'mark'}->{'SELECTION_STOP'}  = undef;
			if(not exists $curfile->{'mark'}->{$1}) { verbose "$curfile->{'path'}: mark $1 not found"; }
			elsif(not exists $curfile->{'mark'}->{$2}) { verbose "$curfile->{'path'}: mark $2 not found"; }
			else {
				$curfile->{'mark'}->{'SELECTION_START'} = $1;
				$curfile->{'mark'}->{'SELECTION_STOP'}  = $2;
			}
		}
=pod

=item select [COUNT] [char[s] | word[s] | line[s]]

=item copy

=item cut

=item paste

=item insert file FILE

=item insert output of COMMAND;

=cut
		elsif($instructions =~ s/insert (?<WHAT>file|output of)$EOIT//)
		{
			my $source_type = $+{'WHAT'};
			my $source = get_text_parameter \$instructions;
			croak "$0: file/command not given to insert" unless length $source;
			my $stream_data = {};
			
			if($source_type eq 'file')
			{
				open $stream_data->{'handle'}, '<', $source or croak "$0: $source: open: $!";
				$stream_data->{'path'} = $source;
			}
			else  # command
			{
				open $stream_data->{'handle'}, '-|', $source or croak "$0: open pipe of \"$source\": $!";
				$stream_data->{'path'} = "|$source";
			}
			
			insert_stream $curfile, $stream_data;
			close $stream_data->{'handle'};
		}
=pod

=item filter through COMMAND;

=item send to COMMAND;

=item uppercase

=item lowercase

=item capitalize

=cut
		elsif($instructions =~ s/^(uppercase|lowercase|capitalize)$EOIT//)
		{
			if($selection_start)
			{
				seeker $curfile, $selection_start, SEEK_SET;
				# TODO
			}
			else
			{
				verbose "$curfile->{'path'}: there is not any selection";
			}
		}
		elsif($instructions eq '')
		{
			last;
		}
		else
		{
			croak "$0: invalid instruction: $instructions";
		}
	}

=pod

=back

=cut
	
	my $close_err = 0;
	for my $curfile (values %openedfile)
	{
		close $curfile->{'handle'} and next;
		$close_err = $!;
		warn "$0: $curfile->{'path'}: close: $!\n";
	}
	return $close_err;
}


$Instructions = join ' ', map { if(/[ ""]/ or $_ eq ''){ s/[""]/\\$&/g; $_="\"$_\""; }; $_ } @ARGV;
croak "$0: not any editing instruction given" unless $Instructions;
#warn Dumper $Instructions;


# TODO optional backup files

exit process_instructions $Instructions;
