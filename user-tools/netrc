#!/usr/bin/env perl

use Data::Dumper;
use POSIX qw/SEEK_END SEEK_SET/;
use Pod::Usage;


=pod

=head1 NAME

netrc - manage ~/.netrc file

=head1 SYNOPSIS

netrc list [I<PROPERTY_NAME> [I<PROPERTY_NAME> [...]]]

netrc set [machine I<MACHINE_NAME> | default] I<PROPERTY_NAME> I<PROPERTY_VALUE> [I<PROPERTY_NAME> I<PROPERTY_VALUE> [...]]

=head1 DESCRIPTION

Query entries from F<~/.netrc> file.
Set and add properties as well as new entries.

=head1 ENVIRONMENT

=over 4

=item NETRC_PATH

Alternative path instead of F<~/.netrc>.

=back

=head1 LIMITATIONS

File is not locked during read/write.

=head1 SEE ALSO

netrc(5)

=cut


sub parse_dotnetrc_file
{
	my $fh = shift;
	my $netrc = {};
	
	local $/ = undef;
	local $_ = <$fh>;
	
	# ignore comments while keeping file positions
	s/\x23.*$/" " x length $&/gem;
	# don't stop parsing at newlines (also keeping positions)
	s/\n/ /g;
	
	my $machine_ref = {};
	my $offset_token_start = 0;
	my $offset_token_end = 0;
	
	while(s/(.*?)(\S+)//)
	{
		my $token = $2;
		$offset_token_start = $offset_token_end + length $1;
		$offset_token_end += length($1) + length($2);
		
		if($token eq 'default')
		{
			if(exists $netrc->{machine}->{''})
			{
				warn "$0: default machine at offset $offset_token_start is already defined at offset $netrc->{machine}->{''}->{offset}\n";
				$machine_ref = {};
			}
			else
			{
				$netrc->{machine}->{''} = {};
				$machine_ref = $netrc->{machine}->{''};
				$machine_ref->{offset} = $offset_token_start;
			}
		}
		else
		{
			s/(.*?)(\S+)//;
			my $next_token = $2;
			$offset_token_start = $offset_token_end + length $1;
			$offset_token_end += length($1) + length($2);
		
			if($token eq 'machine')
			{
				my $machine = $next_token;
				if(exists $netrc->{machine}->{$machine})
				{
					warn "$0: machine $machine at offset $offset_token_start is already defined at offset $netrc->{machine}->{$machine}->{prop}->{machine}->{offset}\n";
					$machine_ref = {};
					# TODO support multiple machines with the same name, eg. in a non-standard "login@machine" form
				}
				else
				{
					$netrc->{machine}->{$machine} = {};
					$machine_ref = $netrc->{machine}->{$machine};
					$machine_ref->{prop}->{machine}->{value} = $machine;
					$machine_ref->{prop}->{machine}->{offset} = $offset_token_start;
				}
			}
			else
			{
				$machine_ref->{prop}->{$token}->{value} = $next_token;
				$machine_ref->{prop}->{$token}->{offset} = $offset_token_start;
			}
			
			# TODO support 'macdef' token
		}
	}
	return $netrc;
}

sub list
{
	my $netrc = shift;
	my @props = @_;
	my $out = '';
	$out .= "MACHINE\t".(join "\t", map {uc} @props)."\n";
	for my $machine (sort keys %{$netrc->{machine}})
	{
		$out .= join("\t",
			$machine,
			map {$netrc->{machine}->{$machine}->{prop}->{$_}->{value}}
				@props
			).
		"\n";
	}
	return $out;
}



$DotNetRcFile = $ENV{NETRC_PATH} || $ENV{HOME}."/.netrc";
$cmd = shift @ARGV;


if($cmd eq 'list')
{
	open my $fh, '<', $DotNetRcFile;
	my $netrc = parse_dotnetrc_file $fh;
	close $fh;
	
	my @props = @ARGV;
	if(not @props) { @props = ('login',); }
	print list($netrc, @props);
}
elsif($cmd eq 'set')
{
	my $machine_name;
	{
		my $match_prop_name = shift @ARGV;
		if($match_prop_name eq 'machine')
		{
			$machine_name = shift @ARGV;
		}
		elsif($match_prop_name eq 'default')
		{
			$machine_name = '';
		}
		else
		{
			die;
		}
	}
	
	open my $fh, '+<', $DotNetRcFile or die "$0: $DotNetRcFile: $!\n";
	my $netrc = parse_dotnetrc_file $fh;
	
	while(@ARGV)
	{
		my $prop_name = shift @ARGV;
		my $prop_value = shift @ARGV;
		
		if(not exists $netrc->{machine}->{$machine_name})
		{
			seek $fh, -1, SEEK_END or die "$0: seek: $!\n";
			my $endchar;
			read $fh, $endchar, 1 or die "$0: read: $!\n";
			my $fpos = tell $fh;
			my $insert_1 = ($endchar eq "\n" ? '' : "\n") . "machine ";
			print {$fh} $insert_1 . $machine_name or die "$0: write: $!\n";
			$netrc->{machine}->{$machine_name}->{prop}->{machine} = {
				offset => $fpos + length $insert_1,
				value => $machine_name,
			};
		}
		
		my $insert_text;
		my $erase_length = 0;
		my $fpos = $netrc->{machine}->{$machine_name}->{prop}->{$prop_name}->{offset};
		
		if(defined $fpos)
		{
			$insert_text = $prop_value;
			$erase_length = length $netrc->{machine}->{$machine_name}->{prop}->{$prop_name}->{value};
		}
		else
		{
			# no such property for this machine.
			# append to the end of the last property value.
			my @props = sort {$b->{offset} <=> $a->{offset}} values %{$netrc->{machine}->{$machine_name}->{prop}};
			die unless @props;
			$fpos = $props[0]->{offset} + length $props[0]->{value};
			$insert_text = " $prop_name $prop_value";
		}
		
		my $insert_length = length $insert_text;
		my $length_diff = $insert_length - $erase_length;
		my $rest_of_the_file;
		
		seek $fh, $fpos, SEEK_SET or die "$0: seek: $!\n";
		{
			local $/ = undef;
			$rest_of_the_file = substr <$fh>, $erase_length;
		}
		seek $fh, $fpos, SEEK_SET or die "$0: seek: $!\n";
		print {$fh} $insert_text.$rest_of_the_file or die "$0: write: $!\n";
		truncate $fh, $fpos + $insert_length + length $rest_of_the_file;
		
		# adjust offsets
		for my $machine (values %{$netrc->{machine}})
		{
			for my $prop ($machine, values %{$machine->{prop}})
			{
				$prop->{offset} += $length_diff if defined $prop->{offset} and $prop->{offset} > $fpos;
			}
		}
	}
	
	close $fh;
}
else
{
	pod2usage(-exitval=>2, -verbose=>99);
}
