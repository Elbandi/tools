#!/usr/bin/env perl

=pod

=head1 NAME

pcut - Cut given fields of text input separated by the given Perl regex

=head1 SYNOPSIS

pcut [I<OPTIONS>] [I<FILE> [I<FILE> [...]]]

=head1 DESCRIPTION

=head1 OPTIONS

=over 4

=item -f, --fields I<NUMBERS>

Counted from 1.
See cut(1) for syntax.

=item -d, --delimiter I<REGEX>

Default is whitespace (C<\s+>).

=item --complement

TODO

=item -s, --only-delimited

TODO

=item -D, --output-delimiter I<STRING>

Define what to delimit fields on the output with.
Default is not to use a constant output delimiter,
but to preserve the separator substrings as they matched to the pattern of B<-d> option
(see B<--prefer-preceding-delimiter> and B<--prefer-succeeding-delimiter> options).

=item -P, --prefer-preceding-delimiter

=item --prefer-succeeding-delimiter (default)

Contrary to cut(1), pcut(1) does not always use a constant delimiter char,
but a regexp pattern which may match to different substrings between fields.

Each output field (except the last one) is followed by the same delimiter substring
(matched to the pattern given as delimiter pattern at B<-d> option) which is after that field in the input.

With B<--prefer-preceding-delimiter>, each output field (except the first one) is similarly preceded by the delimiter substring
which is before that field in the input.

=item -z, --zero-terminated

=back

=head1 LIMITATIONS

=head1 SEE ALSO

cut(1)

=cut


use Data::Dumper;
use Errno qw/:POSIX/;
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev require_order/;
use List::MoreUtils qw/all any none/;
use Pod::Usage;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';

@OptFields = ();
$OptDelimiter = '\s+';
$OptOutputDelimiter = undef;
$OptOutputDelimiterPreceding = 0;

GetOptions(
	'f|fields=s@' => \@OptFields,
	'd|delimiter=s' => \$OptDelimiter,
	'z|zero-terminated' => \$OptZeroTerminated,
	'D|output-delimiter=s' => \$OptOutputDelimiter,
	'P|prefer-preceding-delimiter' => \$OptOutputDelimiterPreceding,  # TODO
	'prefer-succeeding-delimiter' => sub { $OptOutputDelimiterPreceding = 0; },
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'<>' => sub { unshift @ARGV, @_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);

if(defined $OptOutputDelimiter and $OptOutputDelimiterPreceding)
{
	die "$0: Options -D and -P are mutually exclusive.\n";
}

if(not @OptFields)
{
	push @OptFields, '1-';
}

@OptFields = map {split /,/} @OptFields;

for my $fields (@OptFields)
{
	die "$0: invalid fields: $fields\n" unless $fields =~ /^(\d+(-(\d+)?)?|-\d+)$/;
}

sub unzip
{
	[map { $_[$_*2]   } (0 .. $#_ / 2)],
	[map { $_[$_*2+1] } (0 .. $#_ / 2)];
}

sub zip_evenlist
{
	map { $_[$_], $_[$_ + ($#_+1)/2] } (0 .. $#_/2);
}

$\ = "";

eval 'use ARGV::readonly; 1' or die;

while(<>)
{
	chomp;
	my ($Field, $Delimiter) = unzip split /($OptDelimiter)/;
	
	for my $fields (@OptFields)
	{
		if($fields =~ /^(\d+)$/)
		{
			print $Field->[$1-1] . $Delimiter->[$1-1];
		}
		else
		{
			my $from;
			my $to;
			if($fields =~ /^(\d+)-(\d+)$/) { ($from, $to) = ($1-1, $2-1); }
			elsif($fields =~ /^(\d+)-$/) { ($from, $to) = ($1-1, $#$Field); }
			elsif($fields =~ /^-(\d+)$/) { ($from, $to) = (0, $1-1); }
			else { die 'SHOULD-NOT-REACHED'; }
			print join '', zip_evenlist(@{$Field}[$from..$to], @{$Delimiter}[$from..$to]);
		}
	}
	
	if($OptZeroTerminated)
	{
		print chr(0);
	}
	else
	{
		print "\n";
	}
}
