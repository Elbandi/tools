#!/bin/bash

if [ -z "$1" ]
then
	files=([0-9][0-9]-*.test)
else
	files=("$@")
fi

GROUP=`id -gn`
PASSED=0
FAILED=0


subs_self()
{
	local s=$1
	s=${s/SELF:/$USER:}
	s=${s/:SELF/:$GROUP}
	s=${s/SELF/$USER}
	echo $s
}

sort_by_line_length()
{
	local line
	while read -r line
	do
		echo "${#line} $line"
	done |\
	sort -nr |\
	while read -r x line
	do
		echo "$line"
	done
}


for testfile in "${files[@]}"
do
	tcase=`basename "$testfile" .test`
	echo "TEST CASE $tcase ... RUNNING"
	
	(
		set -e
		set -o pipefail
		
		cat "$testfile" |\
		sed -e '/^\s*\(#\|$\)/d' |\
		{
			testdir=`mktemp -d "_test.$tcase.XXXXXX"`
			
			(
				echo CHDIR "$testdir" >&2
				cd "$testdir"
				status_checked=no
				exit_status=''
				
				while read -r section
				do
					case $section in
					setting)
						declare -A chmod=()
						declare -A chown=()
						
						while read -r mode owner file
						do
							if [ $mode = end ]; then break; fi
							
							if [[ $file =~ (.+)\ -\>\ (.+) ]]
							then
								file=${BASH_REMATCH[1]}
								target=${BASH_REMATCH[2]}
								
								mkdir -p "$(dirname "$file")"
								ln -sn "$target" "$file"
							else
								if [ "${file: -1}" = / ]
								then
									mkdir -p "$file"
								else
									mkdir -p "$(dirname "$file")"
									echo -n x >"$file"
								fi
								
								chmod[$file]=$mode
							fi
							
							owner=`subs_self "$owner"`
							chown[$file]=$owner
						done
						
						for file in "${!chmod[@]}"; do echo "$file"; done |\
						sort_by_line_length |\
						while read -r file
						do
							mode=${chmod[$file]}
							chmod $mode "$file"
						done
						
						for file in "${!chown[@]}"; do echo "$file"; done |\
						sort_by_line_length |\
						while read -r file
						do
							owner=${chown[$file]}
							../chown --no-dereference $owner "$file" </dev/null
						done
						;;
					action)
						status_checked=no
						exit_status=''
						
						cmd_args=()
						while read -r arg
						do
							if [ ."$arg" = .end ]; then break; fi
							cmd_args+=($arg)
						done
						
						set +e
						"${cmd_args[@]}" </dev/null
						exit_status=$?
						set -e
						;;
					expections)
						while read -r propname desire file
						do
							if [ $propname = end ]
							then
								if [ $status_checked = no ]
								then
									if [ $exit_status != 0 ]
									then
										echo "Exit status: $exit_status" >&2
										false
									fi
								fi
								break
							fi
							
							case $propname in
							owner)
								fact=`stat -c %U "$file" 2>/dev/null || true`
								desire=${desire/SELF/$USER}
								;;
							group)
								fact=`stat -c %G "$file" 2>/dev/null || true`
								desire=${desire/SELF/$GROUP}
								;;
							exists)
								fact=`stat -c yes "$file" 2>/dev/null || echo no`
								;;
							type)
								fact=`ls -ld "$file" | cut -c1`
								fact=${fact/-/f}
								;;
							status)
								fact=$exit_status
								status_checked=yes
								;;
							esac
							
							if [ "$desire" != "$fact" ]
							then
								echo "Expection failed: $file $propname - desired '$desire', detected '$fact'" >&2
								false
							fi
						done
						;;
					*)
						echo "WARN: Unsupported section: $section" >&2
						while read -r x y
						do
							if [ $x = end ]; then break; fi
						done
						;;
					esac
				done
			)
			
			# delete test base directory if we can
			rm -r "$testdir" 2>/dev/null || true
		}
	)
	
	if [ $? = 0 ]
	then
		echo "TEST CASE $tcase ... PASSED"
		PASSED=$((PASSED + 1))
	else
		echo "TEST CASE $tcase ... FAILED"
		FAILED=$((FAILED + 1))
	fi
done

echo "-------------
PASSED $PASSED/$((PASSED + FAILED))" >&2
